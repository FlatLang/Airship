package flat/airship

import flat/log/Logger
import flat/datastruct/HashMap
import flat/datastruct/HashSet
import flat/datastruct/Pair
import flat/regex/Pattern
import flat/json/JsonDeserializer
import flat/io/File
import flat/io/FileReader
import flat/fucli/FuCli
import flat/fucli/CliArg
import flat/git/Git
import flat/time/Timer

import flat/airship/services

import flat/regex/RegexStringExtensions

class {
  visible static String flatHome = getFlatHome()

  visible Package package
  visible String outFile
  visible Bool debug
  visible String flatJsonLocation
  visible File flatJsonFile
  visible File packageLocation
  visible String target
  visible String targetRuntime

  visible CliArg targetArg = CliArg(
    name: "--target",
    aliases: ["-t"],
    count: 1,
    description: "Specify the target language to compile the package to"
  )

  visible CliArg targetRuntimeArg = CliArg(
    name: "--target-runtime",
    aliases: ["--runtime", "-r"],
    count: 1,
    description: "Specify the target runtime the binary will build for"
  )

  visible CliArg fileArg = CliArg(
    name: "--file",
    aliases: ["-f"],
    count: 1,
    description: "Specify an explicit flat.json file to reference when running the Airship commands"
  )

  visible CliArg linkArg = CliArg(
    name: "--link",
    minCount: 0,
    maxCount: 1,
    description: "Link the Flat package to the h location in #{flatHome}/packages"
  )

  visible CliArg debugArg = CliArg(
    name: "--debug",
    aliases: ["-d"],
    description: "Print the command used to compile the package to stdout and exit"
  )

  visible CliArg syncArg = CliArg(
    name: "--sync",
    aliases: ["-s"],
    description: "Run the compilation synchronously"
  )

  visible CliArg noReplaceLogLineArg = CliArg(
    name: "--no-replace-log-line",
    description: "Do not replace the logging info output after each line"
  )

  visible CliArg quietArg = CliArg(
    name: "--quiet",
    aliases: ["-q"],
    description: "Do not print Airship log messages"
  )

  visible CliArg flatcRuntimeArg = CliArg(
    name: "--flatc-runtime",
    count: 1,
    description: "Specify the Flat compiler runtime"
  )

  visible CliArg versionCommand = CliArg(
    name: "--version",
    count: 0,
    description: "Print version info and exit"
  )

  visible CliArg uninstallArg = CliArg(
    name: "--uninstall",
    description: "Uninstall the Airship package"
  )

  visible CliArg reinstallArg = CliArg(
    name: "--reinstall",
    description: "Reinstall the Airship package"
  )

  visible CliArg setupCommand = CliArg(
    name: "setup",
    description: "Setup the Airship CLI"
  )

  visible CliArg installCommand = CliArg(
    name: "install",
    aliases: ["i"],
    minCount: 0,
    description: "Install a Flat package"
  )

  visible CliArg getCommand = CliArg(
    name: "get",
    minCount: 0,
    description: "Install the specified dependency"
  )

  visible CliArg uninstallCommand = CliArg(
    name: "uninstall",
    minCount: 1,
    description: "Uninstall a Flat package"
  )

  visible CliArg reinstallCommand = CliArg(
    name: "reinstall",
    minCount: 0,
    description: "Reinstall a Flat package"
  )

  visible CliArg updateCommand = CliArg(
    name: "update",
    aliases: ["u"],
    minCount: 0,
    description: "Update a Flat package's dependencies"
  )

  visible CliArg cleanCommand = CliArg(
    name: "clean",
    aliases: ["c"],
    description: "Clean a Flat package's out directory"
  )

  visible CliArg runCommand = CliArg(
    name: "run",
    aliases: ["r"],
    minCount: 1,
    description: "Run a script defined in a flat.json"
  )

  visible CliArg initCommand = CliArg(
    name: "init",
    minCount: 0,
    maxCount: 1,
    description: "Initialize a new Flat package, guided by a CLI prompt"
  )

  visible CliArg createCommand = CliArg(
    name: "create",
    minCount: 1,
    description: "Create Flat package scaffoldings"
  )

  visible CliArg binCommand = CliArg(
    name: "bin",
    description: "Generate a Flat package binary file"
  )

  visible CliArg addDependencyCommand = CliArg(
    name: "add",
    minCount: 1,
    description: "Add a Flat package as a dependency"
  )

  visible CliArg removeDependencyCommand = CliArg(
    name: "remove",
    minCount: 1,
    description: "Remove a Flat package from the dependeciesh"
  )

  visible CliArg helpCommand = CliArg(
    name: "help",
    aliases: ["?"],
    description: "Print help information"
  )

  visible DependencyService dependencyService = DependencyService(this)
  visible AssetService assetService = AssetService(this, dependencyService)
  visible BinaryService binaryService = BinaryService(this, assetService)
  visible InstallService installService = InstallService(this, dependencyService, binaryService)
  visible UninstallService uninstallService = UninstallService(this, dependencyService)
  visible ReinstallService reinstallService = ReinstallService(this)
  visible UpdateService updateService = UpdateService(this, dependencyService, installService)
  visible CleanService cleanService = CleanService(this)
  visible RunScriptService runScriptService = RunScriptService(this)
  visible SetupService setupService = SetupService(this, dependencyService, updateService)
  visible InitService initService = InitService(this)
  visible CreateService createService = CreateService(this)
  visible VersionService versionService = VersionService(this)
  visible GetPackageService getPackageService = GetPackageService(this, installService, dependencyService)
  visible AddDependencyService addDependencyService = AddDependencyService(this, getPackageService, installService)
  visible RemoveDependencyService removeDependencyService = RemoveDependencyService(this, uninstallService)

  static HashMap<String, Airship> packageCache = HashMap()

  static Logger log = Logger(Airship.class)

  public static async main(String[] args) {
    try {
      if (args.count < 2) {
        throw Exception("Missing command")
      }

      Airship(args.skip(1)):run()
    } catch (Exception e) {
      log.error(e.message)
      if (!e.class.isOfType(FlatInstallationFailureException.class)) {
        external {
          console.error(#{e}.error);
        }
      }
      System.exit(1)
    }
  }

  public construct(
    File packageLocationFile,
    Airship parent = null
  ) {
    this(packageLocationFile.normalizedLocation, parent)
  }

  public construct(
    String packageLocation,
    Airship parent = null
  ) {
    this(["-f", packageLocation], parent)
  }

  public construct(
    String[] args,
    Airship parent = null
  ) {
    this(
      FuCli(
        [
          setupCommand,
          installCommand,
          getCommand,
          uninstallCommand,
          reinstallCommand,
          updateCommand,
          cleanCommand,
          runCommand,
          initCommand,
          createCommand,
          binCommand,
          addDependencyCommand,
          removeDependencyCommand,
          helpCommand,
          versionCommand,
          targetArg,
          targetRuntimeArg,
          fileArg,
          linkArg,
          debugArg,
          syncArg,
          noReplaceLogLineArg,
          quietArg,
          uninstallArg,
          reinstallArg,
          flatcRuntimeArg,
        ],
        description: "Flat's package manager",
        usage: "airship {COMMAND} [OPTIONS]"
      ):parse(args),
      parent
    )
  }

  public construct(
    visible FuCli cli,
    visible Airship parent = null
  ) {
    if (helpCommand.enabled) {
      Console.log(cli.getHelpString())
      System.exit(0)
    }

    if (debugArg.enabled) {
      quietArg.enabled = true
    }

    if (quietArg.enabled) {
      Logger.defaultLoggingLevel = Logger.OFF
    }

    log.trace("Creating Airship with CLI args: #cli")

    flatJsonLocation = getFlatJsonLocation(fileArg.value)
    debug = debugArg.enabled
    target = targetArg.value

    flatJsonFile = File(flatJsonLocation).getCanonicalFileSync()
    packageLocation = flatJsonFile.getParent()

    if (packageCache.containsKey(flatJsonFile.normalizedLocation)) {
      log.trace("Airship has already been created for #{flatJsonFile.normalizedLocation}. Using sources from existing package")

      let airship = packageCache[flatJsonFile.normalizedLocation]

      target = target ?: airship.target
      package = airship.package
    } else {
      if (flatJsonFile.isFile) {
        log.trace("Parsing \"#{flatJsonFile.normalizedLocation}\" ...")
        let timer = Timer():start()
        let map = JsonDeserializer().parseObject(flatJsonFile)
        timer.stop()
        log.trace("Parsing \"#{flatJsonFile.normalizedLocation}\" took #{timer.duration}ms")

        let String defaultTarget = (String)map["defaultTarget"]
        target = target ?: defaultTarget
        targetRuntime = targetRuntimeArg.value ?: getDefaultTargetRuntime((String)map["defaultTargetRuntime"])

        let overrideFlatJsonFiles = getFlatJsonOverrides(packageLocation)

        log.debug("Found overrideFlatJsonFiles: #{overrideFlatJsonFiles}")

        for (overrideFlatJsonFile in overrideFlatJsonFiles) {
          let overrideMap = JsonDeserializer().parseObject(overrideFlatJsonFile)

          merge(overrideMap, map)
        }

        package = Package(map)

        loadSources()
      }

      packageCache[flatJsonFile.normalizedLocation] = this
    }
  }

  visible PackageSource[] sources {
    get {
      let value = Array<PackageSource>()

      if (package.mainSource) {
        value.add(package.mainSource)
      }
      if (package.testSource) {
        value.add(package.testSource)
      }

      return value
    }
  }

  public static clearCache(String flatJsonLocation) {
    packageCache.remove(flatJsonLocation)
  }

  public static clearCache(Airship airship) {
    packageCache.removeWhere({ _.key == airship.flatJsonLocation })
  }

  getDefaultTargetRuntime(String configDefaultRuntime) -> String => null {
    if (configDefaultRuntime) return configDefaultRuntime

    match target {
      "js" => "es6" => return "node"
    }
  }

  getFlatJsonLocation(String location) -> String {
    if (!location) {
      return File("#{System.workingDirectory}/flat.json").normalizedLocation
    }

    let file = File(location)

    return if (file.isDirectory || file.isSymbolicLink) {
      file.normalizedLocation + "/flat.json"
    } else if (file.isFile) {
      file.normalizedLocation
    } else {
      throw InvalidFlatJsonException("Invalid flat.json location '#file.location'")
    }
  }

  public static getFlatHome() -> String {
    return if (System.getEnv("FLAT_HOME")) {
      File(System.getEnv("FLAT_HOME")).normalizedLocation
    } else {
      File("#{System.homeDirectory}/.flat").normalizedLocation
    }
  }

  getFlatJsonOverrides(File packageLocation) -> File[] => Array<File>() {
    let os = System.OS.toLowerCase()
    let extensions = String[]

    if (target) {
      extensions.add(target)

      if (target == "es6") {
        extensions.add("js")
      }
    }

    extensions.add(os)

    if (targetRuntime) {
      extensions.add(targetRuntime)
    }

    return searchFlatJsonOverrides(packageLocation, extensions)
  }

  searchFlatJsonOverrides(File packageLocation, String[] extensions) =>
    packageLocation.getChildFiles()
      .filter({ _.name.startsWith("flat.") })
      .filter({ _.extension.equals(".json") })
      .filter({ _.extensionNames.skipLast(1).all({ extensions.contains(_) }) })
      .sort({
        let extensions1 = _a.extensionNames.map({ _.toLowerCase() })
        let extensions2 = _b.extensionNames.map({ _.toLowerCase() })

        let extension1Index = extensions.findIndex({ extensions1.contains(_) }, defaultReturnValue: extensions.count)
        let extension2Index = extensions.findIndex({ extensions2.contains(_) }, defaultReturnValue: extensions.count)

        var Int extension1Score = extension1Index
        var Int extension2Score = extension2Index

        log.trace("|
          Sorting flat json overrides by extension:
            _a.name: #{_a.name}
            _b.name: #{_b.name}
            extensions1: #{extensions1}
            extension1Index: #{extension1Index}
            extension1Score: #{extension1Score}
            extensions2: #{extensions2}
            extension2Index: #{extension2Index}
            extension2Score: #{extension2Score}
            extensions: #{extensions}
          |")

        if (extension1Score == extension2Score) {
          let howManyExtension1 = extensions.howMany({ extensions1.contains(_) })
          let howManyExtension2 = extensions.howMany({ extensions2.contains(_) })

          extension1Score = howManyExtension1
          extension2Score = howManyExtension2

          log.trace("|
              Same score, checking howMany matches:
                extension1Score: #{extension1Score}
                extension2Score: #{extension2Score}
            |")
        }

        if (extension2Score > extension1Score) {
          log.trace("Sorted values to [#{_b.name}, #{_a.name}]")
        } else {
          log.trace("Sorted values to [#{_a.name}, #{_b.name}]")
        }

        return extension2Score - extension1Score
      })

  merge(
    HashMap<String, Object> source,
    HashMap<String, Object> dest
  ) {
    source.forEach((Pair<String, Object> pair) => {
      if (!dest.containsKey(pair.key)) {
        dest[pair.key] = pair.value
      }

      if (pair.value.class.isOfType(HashMap.class)) {
        let HashMap<String, Object> hashmap = (HashMap)pair.value
        let HashMap<String, Object> existingHashmap = (HashMap)dest[pair.key]
        merge(hashmap, existingHashmap)
      } else {
        dest[pair.key] = pair.value
      }
    })
  }

  merge(
    Object[] source,
    Object[] dest
  ) {
    if (!source || !dest) return

    source.stream()
      .filter({ !dest.contains(_) })
      .forEach({ dest.add(_) })
  }

  getDefaultOutDirectory(String packageTarget) -> String {
    match target {
      default => return "dist/#{target}"
    }
  }

  getDefaultOutFile(String packageTarget) -> String {
    match target {
      "js" => fallthrough
      "es6" => {
        match packageTarget {
          "test" => return "test.js"
          default => return "index.js"
        }
      }
      default => return null
    }
  }

  loadSources() {
    package.sources
      .mapValues({
        let source = _x.value
        let outDirectory = validateOutDirectory(source.outDirectory ?: getDefaultOutDirectory(_x.key))
        let outFile = source.outFile ?: getDefaultOutFile(_x.key)
        let updatedSource = source.copy(
          outDirectory: outDirectory,
          outFile: outFile,
          source: source.source ?: "src",
          binaries: source.binaries.map({
            return _x.value
              ? _x
              : _x.copy(value: outDirectory + (outFile ? "/" + outFile : ""))
          })
        )

        log.trace("
            Updating #{_x.key} source from #{source.toString().indent(tab: "  ", firstLine: false)}
            to #{updatedSource.toString().indent(tab: "  ", firstLine: false)}
          |")

        return updatedSource
      })
      .forEach({
        package.sources[_x.key] = _x.value
      })

    if (package.mainSource) {
      package.sources
        .filter({ _.key != "main" })
        .forEach({
          log.trace("Propagating main source dependencies to #{_x.key} source dependencies")
          merge(package.mainSource.dependencies, _x.value.dependencies)
          log.trace("Propagating main source defaultExports to #{_x.key} source defaultExports")
          merge(package.mainSource.defaultExports, _x.value.defaultExports)
        })
    }

    if (!isCoreLibrary()) {
      log.trace("Adding Flat-Core implicit dependency")

      package.sources.forEach({ _.value.dependencies.unshift(GitHubDependency("github:FlatLang/Flat-Core", "master")) })
    } else {
      log.trace("Skipping Flat-Core implicit dependency")
    }
  }

  validateOutDirectory(String location) => location {
    if (location.trim().count == 0) {
      throw InvalidOutDirException("outDirectory cannot be empty")
    } else if (location.trim().startsWith(/[/\\.]/)) {
      throw InvalidOutDirException("outDirectory cannot start with #location.first")
    } else if (location.contains(":/") || location.contains(":\\")) {
      throw InvalidOutDirException("outDirectory cannot be absolute")
    }
  }

  public async run() {
    if (!checkFlatHome()) {
      return
    }

    let commands = cli.args.filter({ _.enabled })

    for (command in commands) {
      log.debug("Running command \"#command\"")

      match (command) {
        setupCommand => setupService.setup()
        installCommand => installService.install()
        getCommand => getPackageService.getPackages(command.values)
        uninstallCommand => uninstallService.uninstall()
        reinstallCommand => reinstallService.reinstall()
        updateCommand => updateService.update()
        cleanCommand => cleanService.clean()
        runCommand => runScriptService.runScript(command.value)
        initCommand => initService.init(command.values)
        createCommand => createService.create(command.value, command.values.skip(1))
        binCommand => binaryService.create(command.values)
        versionCommand => versionService.getVersion()
        addDependencyCommand => addDependencyService.addDependencies(command.values)
        removeDependencyCommand => removeDependencyService.removeDependencies(command.values)
      }
    }
  }

  public getSourceForPackage(String installationTarget, PackageSource defaultSource = null) -> PackageSource {
    return package.sources.getOrDefault(installationTarget, { defaultSource })
  }

  async checkFlatHome() => true {
    let flatHomeFile = File("#{flatHome}")

    if (!flatHomeFile.isDirectory) {
      if (!flatHomeFile.getParent().isDirectory) {
        log.error("Invalid FLAT_HOME directory location '#{flatHome}'")
        return false
      }

      flatHomeFile.mkdirs()
    }
  }

  public async getGitOriginUrl() -> String => null {
    let response = Git.getOriginUrl(silent: true)

    if (response.success) {
      let url = response.value

      return if (!url.endsWith(".git")) {
        "#{url}.git"
      } else {
        url
      }
    }
  }

  getRootParent() -> Airship => this {
    if (parent) {
      return parent.getRootParent()
    }
  }

  isCoreLibrary() => getRootParent().packageLocation.normalizedLocation.endsWith("/Flat-Core")

  public propagateArgs(String[] args) {
    if (target) {
      args.addAll(["-t", target])
    }
    if (targetRuntimeArg.enabled) {
      args.addAll(["-r", targetRuntimeArg.value])
    }
    if (quietArg.enabled) {
      args.add("-q")
    }
  }
}
