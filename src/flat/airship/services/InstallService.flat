package flat/airship/services

import flat/airship
import flat/datastruct
import flat/log
import flat/io
import flat/git

class {
  static Logger log = Logger(InstallService.class)

  public construct(
    private Airship airship,
    private DependencyService dependencyService,
    private BinaryService binaryService,
    private AssetService assetService
  ) {}

  public async install() {
    if (airship.installCommand["installationTarget"].values.isEmpty) {
      if (airship.installLinkArg.enabled) {
        if (let gitUrl = airship.getGitOriginUrl()) {
          airship.installLinkArg.value = "."
          installAndLink(gitUrl)
          return
        } else {
          throw InvalidCommandException("#{System.workingDirectory} is not a git repository")
        }
      }
      install("main", install: true)
    } else {
      for (package in airship.installCommand["installationTarget"].values) {
        install(package, install: true)
      }
    }
  }

  public async install(
    String package,
    Bool: install = false,
    Bool: installDependencies = true
  ) {
    if (airship.installLinkArg.enabled) {
      installAndLink(package)
    } else if (package.contains(":")) {
      installDependency(Dependency.fromPackage(package), install, installDependencies)
    } else {
      installLocalPackage(package)
    }
  }

  async checkInstallCompiler() {
    let runtime = airship.flatcRuntimeValueArg.value?.toLowerCase()?.trim() ?: "java"

    match runtime {
      "native" =>
      "java" => return
      "flat" => {
        let package = "github:FlatLang/Flat-Compiler"
        let dependency = Dependency.fromPackage(package)

        if (!dependencyService.isDependencyInstalled(dependency)) {
          Airship(["get", package]):run()
          Airship(["install", "flatc", "-f", dependency.getLocation(), "--flatc-runtime", "java"]):run()
        }
      }
      default => throw ExecutionFailureException("Invalid flatc runtime \"#{runtime}\"")
    }
  }

  async checkInstallTarget() {
    if (!airship.target) return

    let target = match airship.target.toLowerCase() {
      "es6" => "ES6"
      "js" => "JS"
      "java" => "Java"
      "c" => "C"
      default => airship.target
    }

    let package = "github:FlatLang/Flat-#{target}"
    let dependency = Dependency.fromPackage(package)

    if (!dependencyService.isDependencyInstalled(dependency)) {
      Airship(["install", package, "--flatc-runtime", "java"]):run()
    }
  }

  getOutputDirectory(PackageSource source) => File("#{airship.packageLocation.normalizedLocation}/#{source.outDirectory}")

  public async getInstallCommand(String installationTarget, PackageSource source) -> String[] {
    return getFlatcExecutableCommand().plus(getFlatcExecutableArguments(installationTarget, source))
  }

  getFlatcExecutableCommand() -> String[] {
    let runtime = airship.flatcRuntimeValueArg.value?.toLowerCase()?.trim() ?: "java"

    match runtime {
      "native" => {
        let nativeFileName = match System.OS_INT {
          System.WINDOWS => "flatc.exe"
          default => "flatc"
        }

        return [
          "#{Airship.flatHome}/packages/Flat/target/#{nativeFileName}",
        ]
      }
      "java" => {
        return [
          "java",
          "-jar",
          "#{Airship.flatHome}/packages/Flat/target/flatc.jar",
        ]
      }
      "flat" => {
        return [
          "flatc",
        ]
      }
      default => {
        throw ExecutionFailureException("Invalid flatc runtime \"#{runtime}\"")
      }
    }
  }

  async getFlatcExecutableArguments(String installationTarget, PackageSource source) -> String[] {
    let runtime = airship.flatcRuntimeValueArg.value?.toLowerCase()?.trim() ?: "java"

    match runtime {
      "native" =>
      "java" => return getLegacyInstallArguments(installationTarget, source)
      "flat" => return getFlatcInstallArguments(installationTarget, source)
      default => throw ExecutionFailureException("Invalid flatc runtime \"#{runtime}\"")
    }
  }

  public async getLegacyInstallArguments(String installationTarget, PackageSource source) -> String[] {
    let args = String[]

    let currentDependency = Dependency.fromPackage("local:#{airship.packageLocation.normalizedLocation}")
    let sourceLocations = dependencyService.getDependencySourceLocations(currentDependency, installationTarget)
    let excludeSources = dependencyService.getDependencyExclusions(currentDependency, installationTarget)
    let excludeSource = installationTarget == "test" ? null : dependencyService.getDependencySourceGlobLocation(currentDependency, "test")
    let canonicalSourceLocations = sourceLocations.mapParallel({ File(_).getCanonicalPath() }).unique()

    log.trace("Adding source locations: #{sourceLocations}")
    args.addAll(sourceLocations.map({ "\"#_\"" }))

    args.addAll([
      "-install-dir", "#{Airship.flatHome}/packages",
    ])

    if (source.outFile) {
      args.addAll(["-o", "#{getOutputDirectory(source).location}/#{source.outFile}"])
    } else {
      args.addAll(["-d", getOutputDirectory(source).location])
    }

    if (airship.target) {
      log.trace("Adding target: #{airship.target}")
      args.addAll(["-target", airship.target])
    }
    if (airship.targetRuntimeArg.enabled) {
      log.trace("Adding source locations: #{airship.targetRuntimeArg["runtime"].value}")
      args.addAll(["-target-runtime", airship.targetRuntimeArg["runtime"].value])
    }
    if (!airship.syncArg.enabled) {
      args.add("-parallel")
    }
    if (airship.noReplaceLogLineArg.enabled) {
      args.add("-no-replace-log-line")
    }

    log.trace("Adding source exclusions: #{excludeSources}")
    excludeSources.forEach({ args.addAll(["-x", "\"#_\""]) })

    if (excludeSource) {
      args.addAll(["-x", "\"#excludeSource\""])
    }

    let response = dependencyService.getDependenciesForSource(installationTarget, installationTarget, source)
    log.trace("All dependencies for \"#installationTarget\": #response.dependencies")

    let topLevelDependencies = dependencyService.getDependenciesForSource(installationTarget, installationTarget, source, recursive: false)
    log.trace("Tep-level dependencies for \"#installationTarget\": #topLevelDependencies.dependencies")

    let dependencyLocations = HashMap<Dependency, Array<String>>()
    let excludeLocations = HashMap<Dependency, Array<String>>()

    response.dependencies.forEachParallel({
      if (!dependencyLocations.containsKey(_x)) {
        let dependencySourceLocations = dependencyService.getDependencySourceLocations(_x, installationTarget)

        dependencyLocations[_x] = Array()

        for (src in dependencySourceLocations) {
           dependencyLocations[_x].add(File(src).getCanonicalPath())
        }
      }
    })

    response.dependencies
      .filter({ _.isFlatPackage() })
      .filter({ dependencyLocations[_].none({ canonicalSourceLocations.contains(_) }) })
      .forEach({
        dependencyService
          .getDependencySourceLocations(_x)
          .forEach({ args.addAll(["-l", "\"#_\""]) })

        dependencyService
          .getDependencyExclusions(_x, installationTarget)
          .forEach({ args.addAll(["-x", "\"#_\""]) })

        let dependencyExcludeSource = dependencyService.getDependencySourceGlobLocation(_x, "test")

        if (dependencyExcludeSource) {
          args.addAll(["-x", "\"#dependencyExcludeSource\""])
        }
      })

    source.defaultExports
      .filter({ !_.staticImport })
      .forEach({ args.addAll(["-default-import", "\"#{_.location}\""]) })

    source.defaultExports
      .filter({ _.staticImport })
      .forEach({ args.addAll(["-default-static-import", "\"#{_.location}\""]) })

    topLevelDependencies.dependencies
      .filter({ _.isFlatPackage() })
      .filter({ dependencyLocations[_].none({ canonicalSourceLocations.contains(_) }) })
      .forEach({
        let childship = _x.airship
        let dependencySource = childship.getSourceForPackage(installationTarget, childship.package.defaultSource)

        dependencySource?.defaultExports
          .filter({ !_.staticImport })
          .forEach({ args.addAll(["-default-import", "\"#{_.location}\""]) })

        dependencySource?.defaultExports
          .filter({ _.staticImport })
          .forEach({ args.addAll(["-default-static-import", "\"#{_.location}\""]) })
      })

    if (source.mainClass) {
      args.addAll(["-main", source.mainClass])
    } else {
      args.add("-library")
    }

    return args
  }

  public async getFlatcInstallArguments(String installationTarget, PackageSource source) -> String[] {
    let args = String[]

    let currentDependency = Dependency.fromPackage("local:#{airship.packageLocation.normalizedLocation}")
    let sourceLocations = dependencyService.getDependencySourceLocations(currentDependency, installationTarget)
    let excludeSources = dependencyService.getDependencyExclusions(currentDependency, installationTarget)
    let excludeSource = installationTarget == "test" ? null : dependencyService.getDependencySourceGlobLocation(currentDependency, "test")
    let canonicalSourceLocations = sourceLocations.mapParallel({ File(_).getCanonicalPath() }).unique()

    log.trace("Adding source locations: #{sourceLocations}")
    args.addAll(sourceLocations.map({ "\"#_\"" }))

    return args
  }

  async installLocalPackage(String package) {
    log.debug("Installing local package #{airship.packageLocation.normalizedLocation} with target \"#package\"")

    let source = airship.getSourceForPackage(package, airship.parent ? airship.package.defaultSource : null)

    if (!source) {
      log.debug("No source for local package #{airship.packageLocation.normalizedLocation}. Skipping installation")
      return
    }

    let dependencies = installDependencies(package, source)

    checkInstallTarget()
    checkInstallCompiler()

    let cmd = getInstallCommand(package, source)

    if (airship.debug) {
      Console.writeLine(cmd[0] + " " + cmd.skip(1).map({ '"' + _.trimStart('"').trimEnd('"') + '"' }).join(" "))
      return
    }

    log.debug("Executing command: #cmd")

    let response = System.execute(cmd, silent: airship.quietArg.enabled)

    if (response.exitCode != 0) {
      throw FlatInstallationFailureException("Compilation failed: exit code #{response.exitCode}")
    }

    assetService.copyAssets(getOutputDirectory(source), package, source)

    if (source.binaries.count > 0) {
      binaryService.create(package)
    }

    log.debug("Successful installation")
  }

  public async installDependency(
    Dependency dependency,
    Bool: build = true,
    Bool: install = true,
    Bool: installDependencies = true
  ) {
    if (!dependencyService.isDependencyInstalled(dependency)) {
      log.debug("Installing dependency #{dependency}")
      dependencyService.installDependency(dependency)
    } else {
      log.debug("Dependency #{dependency} already installed")
    }

    if (dependency.isFlatPackage()) {
      postInstallPackage(
        File(dependency.getLocation()),
        build,
        install,
        installDependencies
      )
    }
  }

  async installAndLink(String url) {
    let start = url.lastIndexOf('/') + 1
    let end = url.lastIndexOf('.')

    if (start > end) {
      throw InvalidFlatJsonException("Invalid repo url '#url'")
    }

    let packageName = url.substring(start, end)
    let flatPackageDir = File("#{Airship.flatHome}/packages/#{packageName}")

    flatPackageDir.symbolicLinkTo(File("#{System.workingDirectory}/#{airship.installLinkArg.value}"))

    postInstallPackage(flatPackageDir, install: false)
  }

  async installDependencies(
    String package,
    PackageSource source,
    Bool install = false
  ) -> Dependency[] {
    let response = dependencyService.getDependenciesForSource(package, package, source)

    log.trace("Installing dependencies for source #{source}")
    log.trace("Dependencies #{response.dependencies}")

    for (dependency in response.dependencies) {
      installDependency(
        dependency,
        build: response.dependenciesDownloaded.contains(dependency),
        install: false,
        installDependencies: false
      )
    }

    return response.dependencies
  }

  async postInstallPackage(
    File flatPackageDir,
    Bool: build = true,
    Bool: install = true,
    Bool: installDependencies = true
  ) {
    log.debug("Post-installation for package #{flatPackageDir.nativeLocation}")

    let args = [
      "-f", flatPackageDir.normalizedLocation
    ]

    airship.propagateArgs(args)

    let childship = Airship(args, airship)

    if (build && childship.package?.scripts?.containsKey("build")) {
      if (childship.package.scripts.containsKey("clean")) {
        childship.runScriptService.runScript("clean")
      }

      childship.runScriptService.runScript("build")
    }

    if (childship.package?.mainSource) {
      if (installDependencies) {
        childship.installService.installDependencies(flatPackageDir.name, childship.package.defaultSource)
      }
      if (install) {
        childship.installService.install()
      }
    }
  }
}
