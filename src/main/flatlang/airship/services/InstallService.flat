package "flatlang/airship/services"

import "flatlang/io/File"
import "flatlang/airship/Airship"
import "flatlang/airship/PackageSource"
import "flatlang/airship/InvalidCommandException"
import "flatlang/airship/InvalidFlatJsonException"

class {
  public construct(private Airship airship) {}

  public async install() -> Int[] {
    let exitCodes = new Array<Int>()

    if (airship.installCommand.values.isEmpty) {
      if (airship.linkArg.enabled) {
        if (let gitUrl = await airship.getGitOriginUrl()) {
          airship.linkArg.value = "."
          return [await installAndLink(gitUrl)]
        } else {
          throw new InvalidCommandException("#{System.workingDirectory} is not a git repository")
        }
      }
      return exitCodes:add(await install("main"))
    }

    for (package in airship.installCommand.values) {
      exitCodes.add(await install(package))
    }

    return exitCodes
  }

  public async install(String package, Bool install = true, Bool installDependencies = true) -> Int {
    if (airship.linkArg.enabled) {
      return await installAndLink(package)
    } else if (package.endsWith(".git")) {
      return await installGitPackage(package, install, installDependencies)
    } else {
      return await installLocalPackage(package)
    }
  }

  public async getInstallCommand(String package, PackageSource source) -> String[] {
    if (!source) {
      throw new InvalidCommandException("No source found for installation")
    }

    let cmd = [
      "java",
      "-jar",
      "#{airship.flatHome}/packages/Flat/target/flatc.jar",
      "#{airship.packageLocation.normalizedLocation}/#{source.source}",
      "-install-dir", "#{airship.flatHome}/packages",
      "-o", "#{airship.packageLocation.normalizedLocation}/#{source.outDirectory}/#{source.outFile}"
    ]

    if (airship.target) {
      cmd.addAll(["-target", airship.target])
    }

    let allDependencies = await airship.getDependenciesForSource(package, package, source)

    allDependencies.forEach({ cmd.addAll(["-l", airship.getDependencyLocation(_)]) })

    if (source.mainClass) {
      cmd.addAll(["-main", source.mainClass])
    } else {
      cmd.add("-library")
    }

    return cmd
  }

  async installLocalPackage(String package) -> Int {
    let source = airship.getSourceForPackage(package)

    if (!source) {
      throw new InvalidCommandException("No source found for installation package '#package'")
    }

    let dependenciesCode = await installDependencies(package, source)

    if (dependenciesCode != 0) {
      return dependenciesCode
    }

    let cmd = await getInstallCommand(package, source)

    if (airship.debug) {
      Console.writeLine(cmd[0] + " " + cmd.skip(1).map({ "\"#{_}\"" }).join(" "))
      return 0
    }

    let response = await System.execute(cmd)

    return response.exitCode
  }

  public async installGitPackage(String url, Bool install = true, Bool installDependencies = true) -> Int {
    let packageName = url.substring(url.lastIndexOf('/') + 1, url.lastIndexOf('.'))
    let flatPackageDir = await new File("#{airship.flatHome}/packages/#{packageName}"):mkdirs()

    if (flatPackageDir.getChild(".git").isDirectory) {
      return 0
    }

    let response = await System.execute([
      "git",
      "clone",
      url,
      "--depth", "1",
      flatPackageDir.normalizedLocation
    ])

    if (response.exitCode != 0) {
      return response.exitCode
    }

    return await postInstallPackage(
      flatPackageDir,
      install: install,
      installDependencies: installDependencies
    )
  }

  async installAndLink(String url) -> Int {
    let start = url.lastIndexOf('/') + 1
    let end = url.lastIndexOf('.')

    if (start > end) {
      throw new InvalidFlatJsonException("Invalid repo url '#url'")
    }

    let packageName = url.substring(start, end)
    let flatPackageDir = new File("#{airship.flatHome}/packages/#{packageName}")

    await flatPackageDir.symbolicLinkTo(new File("#{System.workingDirectory}/#{airship.linkArg.value}"))

    return await postInstallPackage(flatPackageDir, install: false)
  }

  async installDependencies(String package, PackageSource source) -> Int {
    let exitCodes = new Array<Int>()

    let dependencies = await airship.getDependenciesForSource(package, package, source)

    for (dependency in dependencies.filter({ _.value != "local" })) {
      exitCodes.add(await installGitPackage(airship.getDependencyGitUrl(dependency)))
    }

    return exitCodes.filter({ _ != 0 }).first ?: 0
  }

  async postInstallPackage(
    File flatPackageDir,
    Bool: build = true,
    Bool: install = true,
    Bool: installDependencies = true
  ) -> Int {
    let args = [
      "-f", flatPackageDir.normalizedLocation
    ]

    if (airship.target) {
      args.addAll(["-t", airship.target])
    }

    let airship = await new Airship(args)

    if (build && airship.package?.scripts.containsKey("build")) {
      let buildExitCode = await airship.runScriptService.runScript("build")

      if (buildExitCode != 0) {
        return buildExitCode
      }
    }

    if (install && airship.package?.main) {
      if (installDependencies) {
        let dependenciesExitCode = await airship.installService.installDependencies(flatPackageDir.name, airship.package?.main)

        if (dependenciesExitCode != 0) {
          return dependenciesExitCode
        }
      }

      let installExitCodes = await airship.installService.install()
      let code = installExitCodes.filter({ _ != 0 }).first

      if (code) {
        return code
      }
    }

    return airship.exitCodes.filter({ _ != 0 }).first ?: 0
  }
}