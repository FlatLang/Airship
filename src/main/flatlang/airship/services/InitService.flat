package flatlang/airship/services

import flat/log/Logger

import flatlang/io/File
import flatlang/io/FileWriter
import flatlang/airship/Airship
import flatlang/airship/InvalidScriptException
import flatlang/airship/ExecutionFailureException

import static flat/readline/ReadLine

class {
  let static Logger log = Logger(InitService.class)

  public construct(private Airship airship) {}

  requireValue(String value) => value.trim().count > 0

  public async init() {
    let directory = File(System.workingDirectory)
    let flatJson = File("#{directory.location}/flat.json")

    if (flatJson.exists) {
      throw ExecutionFailureException("#{flatJson.normalizedLocation} exists already")
    }

    let defaultName = directory.name
    let defaultVersion = "0.1.0"
    let defaultLicense = "ISC"
    let defaultDefaultTarget = "es6"

    let name = question("Package name (default: #defaultName): ")
      .trim().orElse(defaultName)
    let version = question("Package version (default: #defaultVersion): ")
      .trim().orElse(defaultVersion)
    let description = question("Package description: ")
      .trim().orElse("")
    let author = question("Package author: ")
      .trim().orElse("")
    let license = question("Package license (default: #defaultLicense): ")
      .trim().orElse(defaultLicense)
    let defaultTarget = question("Default compilation target (default: #defaultDefaultTarget): ")
      .trim().orElse(defaultDefaultTarget)
    let mainClass = question("Main class (e.g.: example/ClassName) [optional - press enter to skip]: ")
      .trim().orElse(null)

    writeSources(mainClass)

    writeFlatJson(
      flatJson,
      name,
      version,
      description,
      author,
      license,
      defaultTarget,
      mainClass
    )
  }

  async writeSources(String mainClass) {
    let sourceRoot = File("src")

    if (!sourceRoot.exists) {
      sourceRoot.mkdir()
    } else if (!sourceRoot.isDirectory) {
      throw ExecutionFailureException("Invalid 'src' directory at #sourceRoot.location")
    }

    if (mainClass) {
      writeMainClassFile(mainClass)
      writeTestFiles(mainClass)
    }
  }

  async writeMainClassFile(String mainClass) {
    let mainClassFile = File("src/#{mainClass}.flat")

    if (!mainClassFile.exists) {
      let packageDirectory = mainClassFile.getParent()

      if (!packageDirectory.exists) {
        packageDirectory.mkdirs()
      }

      let packageEndLocation = mainClass.lastIndexOf("/")
      let packageLocation = packageEndLocation == -1 ?
        "" :
        "package #{mainClass.substring(0, packageEndLocation)}\n\n"

      let mainClassFileContents = "#{packageLocation}class {\n
        \tpublic static main(String[] args) {\n
        \t\t\n
        \t}\n
        }\n".replace("\t", "  ")

      FileWriter(mainClassFile)
        :write(mainClassFileContents)
        .close()
    }
  }

  async writeTestFiles(String mainClass) {
    let mainClassFile = File(mainClass)
    let mainClassTestFile = File("src/#{mainClass}_Test.flat")
    let testSuiteFile = File("src/#{mainClass}_TestSuite.flat")
    let packageDirectory = testSuiteFile.getParent()
    let packageEndLocation = mainClass.lastIndexOf("/")
    let packageLocation = packageEndLocation == -1 ? "" : mainClass.substring(0, packageEndLocation)
    let packageStatement = packageLocation ? "package #packageLocation\n\n" : ""

    if (!packageDirectory.exists) {
      packageDirectory.mkdirs()
    }

    if (!mainClassTestFile.exists) {
      let mainClassTestFileContents = "#{packageStatement}import #{mainClass}\n
\n
        import static novex/nest/Nest\n
\n
        testable class {\n
        \ttest &tick;can create&tick;() {\n
        \t\tlet value = #{mainClassFile.rootName}()\n
\n
        \t\texpect(value).toNotBe(null)\n
        \t}\n
        }\n".replace("\t", "  ").replace("&tick;", "`")

      FileWriter(mainClassTestFile)
        :write(mainClassTestFileContents)
        .close()
    }

    if (!testSuiteFile.exists) {
      let testSuiteFileContents = "#{packageStatement}import novex/nest/TestResult\n
\n
        import flatlang/time/Timer\n
        import flatlang/io/FancyOutputStream\n
\n
        [TestSuite [\n
        \t#{mainClassTestFile.rootName}\n
        ]]\n
        class {\n
        \tpublic static async main(String args[]) {\n
        \t\tlet test = #{testSuiteFile.rootName}()\n
\n
        \t\tTimer timer = Timer().start()\n
\n
        \t\tlet results = new TestResult[]\n
\n
        \t\ttest.runTests({\n
        \t\t\tresults.add(_)\n
        \t\t})\n
\n
        \t\tlet fancy = FancyOutputStream(headerPattern: &quote;/\\\\&quote;)\n
\n
        \t\tlet unsuccessful = results.filter({ !_.success })\n
\n
        \t\tif (unsuccessful.count > 0) {\n
        \t\t\tfancy.writeHeader(&quote;&hash;unsuccessful.count Failure&hash;{unsuccessful.count == 1 ? &quote;&quote; : &quote;s&quote;} out of &hash;results.count test&hash;{results.count == 1 ? &quote;&quote; : &quote;s&quote;}&quote;, pattern: &quote;:'( &quote;, symmetrical: true)\n
\n
        \t\t\tunsuccessful.forEach({\n
        \t\t\t\tConsole.log(&quote;&hash;_&quote;)\n
        \t\t\t})\n
        \t\t} else {\n
        \t\t\tfancy.writeHeader(&quote;All &hash;results.count Successful&quote;, pattern: &quote;:) &quote;, symmetrical: true)\n
        \t\t}\n
\n
        \t\ttimer.stop()\n
\n
        \t\tConsole.writeLine(&quote;Took &quote; + timer.duration + &quote;ms&quote;)\n
\n
        \t\tif (unsuccessful.count > 0) {\n
        \t\t\t\tSystem.exit(1)\n
        \t\t}\n
        \t}\n
        }\n".replace("\t", "  ").replace("&quote;", "\"").replace("&hash;", '#'.toString())

      FileWriter(testSuiteFile)
        :write(testSuiteFileContents)
        .close()
    }
  }

  async writeFlatJson(
    File flatJson,
    String: name,
    String: version,
    String: description,
    String: author,
    String: license,
    String: defaultTarget,
    String: mainClass
  ) {
    let mainClassProperty = mainClass ? "\t\t\"mainClass\": \"#{mainClass}\",\n" : ""
    let testMainClassProperty = mainClass ? "\t\t\"mainClass\": \"#{mainClass}_TestSuite\",\n" : ""

    let jsonContents = "{\n
      \t\"name\": \"#name\",\n
      \t\"version\": \"#version\",\n
      \t\"description\": \"#description\",\n
      \t\"author\": \"#author\",\n
      \t\"license\": \"#license\",\n
      \t\"defaultTarget\": \"#defaultTarget\",\n
      \t\"scripts\": {\n
      \t\t\"test\": \"node dist/test.js\"\n
      \t},\n
      \t\"main\": {\n#mainClassProperty
      \t\t\"source\": \"src\",\n
      \t\t\"dependencies\": {\n
      \t\t}\n
      \t},\n
      \t\"test\": {\n#testMainClassProperty
      \t\t\"source\": \"src\",\n
      \t\t\"dependencies\": {\n
      \t\t\t\"github:FlatLang/Nest\": \"master\"\n
      \t\t}\n
      \t}\n
      }\n
    ".replace("\t", "  ")

    FileWriter(flatJson)
      :write(jsonContents)
      .close()
  }
}