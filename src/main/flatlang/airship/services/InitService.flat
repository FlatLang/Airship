package flatlang/airship/services

import flat/log/Logger

import flatlang/io/File
import flatlang/io/FileWriter
import flatlang/airship/Airship
import flatlang/airship/InvalidScriptException
import flatlang/airship/ExecutionFailureException

import static flat/readline/ReadLine
import static flat/colorizer/Colorizer

class {
  let static Logger log = Logger(InitService.class)

  public construct(private Airship airship) {}

  requireValue(String value) => value.trim().count > 0

  public async init() {
    var directory = File(System.workingDirectory)

    let defaultName = directory.name
    let defaultVersion = "0.1.0"
    let defaultLicense = "ISC"
    let defaultDefaultTarget = "es6"

    let name = question("#{cyan("Package name")} (default: #{underscore(defaultName)}): ")
      .trim().orElse(defaultName)

    let currentDirectory = underscore(directory.normalizedLocation)
    let useCurrentFolder = boolQuestion(cyan("Initialize package in current folder") + ": \"#{currentDirectory}\"? (Y/n): ")

    if (!useCurrentFolder) {
      let folderName = question("#{cyan("Folder name")} (default: #{underscore(name)}): ")
        .trim().orElse(name)

      directory = File("#{directory.normalizedLocation}/#{folderName}"):mkdir()
    }

    let flatJson = File("#{directory.normalizedLocation}/flat.json")

    if (flatJson.exists) {
      throw ExecutionFailureException("#{flatJson.normalizedLocation} exists already")
    }

    let version = question("#{cyan("Package version")} (default: #{underscore(defaultVersion)}): ")
      .trim().orElse(defaultVersion)
    let description = question("#{cyan("Package description")}: ")
      .trim().orElse("")
    let author = question("#{cyan("Package author")}: ")
      .trim().orElse("")
    let license = question("#{cyan("Package license")} (default: #{underscore(defaultLicense)}): ")
      .trim().orElse(defaultLicense)
    let defaultTarget = question("#{cyan("Default compilation target")} (default: #{underscore(defaultDefaultTarget)}): ")
      .trim().orElse(defaultDefaultTarget)
    let mainClass = question("#{cyan("Main class")} (e.g.: #{underscore("example/ClassName")}) [optional - press enter to skip]: ")
      .trim().orElse(null)

    writeFlatJson(
      flatJson,
      name,
      version,
      description,
      author,
      license,
      defaultTarget,
      mainClass
    )

    let createService = CreateService(Airship(flatJson, airship))

    writeSources(directory, mainClass)

    if (mainClass && boolQuestion(cyan("Create a testing pipeline") + "? (Y/n): ")) {
      createService.create("pipeline")
    }
  }

  async writeSources(File directory, String mainClass) {
    let sourceRoot = File("#{directory.normalizedLocation}/src")

    if (!sourceRoot.exists) {
      sourceRoot.mkdir()
    } else if (!sourceRoot.isDirectory) {
      throw ExecutionFailureException("Invalid 'src' directory at #sourceRoot.location")
    }

    if (mainClass) {
      writeMainClassFile(directory, mainClass)
      writeTestFiles(directory, mainClass)
    }
  }

  async writeMainClassFile(File directory, String mainClass) {
    let mainClassFile = File("#{directory.normalizedLocation}/src/#{mainClass}.flat")

    if (!mainClassFile.exists) {
      let packageDirectory = mainClassFile.getParent()

      if (!packageDirectory.exists) {
        packageDirectory.mkdirs()
      }

      let packageEndLocation = mainClass.lastIndexOf("/")
      let packageLocation = packageEndLocation == -1 ? null : mainClass.substring(0, packageEndLocation)
      let packageStatement = packageLocation ? "package #packageLocation" : ""

      let mainClassFileContents = "|
        #{packageStatement}

        class {
          public static main(String[] args) {

          }
        }\n
        |".trimStart()

      FileWriter(mainClassFile)
        :write(mainClassFileContents)
        .close()
    }
  }

  async writeTestFiles(File directory, String mainClass) {
    let mainClassFile = File("#{directory.normalizedLocation}/#{mainClass}")
    let mainClassTestFile = File("#{directory.normalizedLocation}/src/#{mainClass}_Test.flat")
    let testSuiteFile = File("#{directory.normalizedLocation}/src/#{mainClass}_TestSuite.flat")
    let packageDirectory = testSuiteFile.getParent()
    let packageEndLocation = mainClass.lastIndexOf("/")
    let packageLocation = packageEndLocation == -1 ? null : mainClass.substring(0, packageEndLocation)
    let packageStatement = packageLocation ? "package #packageLocation" : ""

    if (!packageDirectory.exists) {
      packageDirectory.mkdirs()
    }

    if (!mainClassTestFile.exists) {
      let mainClassTestFileContents = "|
        #{packageStatement}

        import #{mainClass}

        testable class {
          test `can create`() {
            let value = #{mainClassFile.rootName}()

            expect(value).toNotBe(null)
          }
        }\n
        |".trimStart()

      FileWriter(mainClassTestFile)
        :write(mainClassTestFileContents)
        .close()
    }

    if (!testSuiteFile.exists) {
      let testSuiteFileContents = "|
        #{packageStatement}

        import novex/nest/TestResult

        import flatlang/time/Timer
        import flatlang/io/FancyOutputStream

        [TestSuite [
          #{mainClassTestFile.rootName}
        ]]
        class {
          public static async main(String args[]) {
            let test = #{testSuiteFile.rootName}()

            Timer timer = Timer().start()

            let results = new TestResult[]

            test.runTests({
              results.add(_)
            })

            let fancy = FancyOutputStream(headerPattern: \"/\\\\\")

            let unsuccessful = results.filter({ !_.success })

            if (unsuccessful.count > 0) {
              fancy.writeHeader(
                \"\#unsuccessful.count Failure\#{unsuccessful.count == 1 ? \"\" : \"s\"} out of \#results.count test\#{results.count == 1 ? \"\" : \"s\"}\",
                pattern: \":'( \",
                symmetrical: true
              )

              unsuccessful.forEach({
                Console.log(\"\#_\")
              })
            } else {
              fancy.writeHeader(
                \"All \#results.count Successful\",
                pattern: \":) \",
                symmetrical: true
              )
            }

            timer.stop()

            Console.writeLine(\"Took \#{timer.duration}ms\")

            if (unsuccessful.count > 0) {
                System.exit(1)
            }
          }
        }\n
        |".trimStart()

      FileWriter(testSuiteFile)
        :write(testSuiteFileContents)
        .close()
    }
  }

  async writeFlatJson(
    File flatJson,
    String: name,
    String: version,
    String: description,
    String: author,
    String: license,
    String: defaultTarget,
    String: mainClass
  ) {
    let mainClassProperty = mainClass ? "\"mainClass\": \"#{mainClass}\",\n    " : ""
    let testMainClassProperty = mainClass ? "\"mainClass\": \"#{mainClass}_TestSuite\",\n    " : ""

    let jsonContents = "|
      {
        \"name\": \"#name\",
        \"version\": \"#version\",
        \"description\": \"#description\",
        \"author\": \"#author\",
        \"license\": \"#license\",
        \"defaultTarget\": \"#defaultTarget\",
        \"scripts\": {
          \"test\": \"node dist/test.js\"
        },
        \"main\": {
          #mainClassProperty\"source\": \"src\",
          \"dependencies\": {
          }
        },
        \"test\": {
          #testMainClassProperty\"source\": \"src\",
          \"dependencies\": {
            \"github:FlatLang/Nest\": \"master\"
          }
        }
      }\n
      |"

    FileWriter(flatJson)
      :write(jsonContents)
      .close()
  }
}