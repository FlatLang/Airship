package "flatlang/airship"

import "flatlang/datastruct/HashMap"
import "flatlang/json/JsonDeserializer"
import "flatlang/io/File"
import "flatlang/io/FileReader"

class {
  visible Package package
  visible String flatHome
  visible String outDirectory
  visible String outFile
  visible String source
  visible Bool debug
  visible PackageSource mainSource
  visible PackageSource testSource

  public static async main(String[] args) {
    if (args.count < 2) {
      throw new Exception("Missing command")
    }

    let airship = await new Airship(args.skip(1)):run()
  }

  public construct(private String[] commands) {
    let packageFile = new File(getFlatJsonPath())
    let map = new JsonDeserializer().parse(packageFile)

    package = new Package((HashMap)map)

    flatHome = System.getEnv("FLAT_HOME")

    mainSource = package.main?.clone(
      outDirectory: validateOutDirectory(package.main.outDirectory ?: "dist"),
      outFile: package.main.outFile ?: "index.js",
      source: package.main.source ?: "src"
    )

    testSource = package.test?.clone(
      outDirectory: validateOutDirectory(package.test.outDirectory ?: "dist"),
      outFile: package.test.outFile ?: "test.js",
      source: package.test.source ?: "src"
    )

    mainSource?.dependencies.forEach(pair => testSource.dependencies.add(pair.key, pair.value))

    debug = commands.any({ _ == "--debug"})
    this.commands = commands.filter({ _ != "--debug"})
  }

  getFlatJsonPath() -> String {
    let fileOverride = commands.firstWhere((command, i) => {
      if (command.equalsIgnoreCase("-f") && i == commands.count - 1) {
        throw new InvalidFlatJsonException("Invalid -f value")
      }

      return i > 0 && commands[i - 1].equalsIgnoreCase("-f")
    })

    return fileOverride ?: "#{System.workingDirectory}/flat.json"
  }

  validateOutDirectory(String location) => location {
    if (location.trim().count == 0) {
      throw new InvalidOutDirException("outDirectory cannot be empty")
    } else if (location.trim().startsWith(/[/\\.]/)) {
      throw new InvalidOutDirException("outDirectory cannot start with #location.first")
    } else if (location.contains(":/") || location.contains(":\\")) {
      throw new InvalidOutDirException("outDirectory cannot be absolute")
    }
  }

  async run() {
    let commandIterator = commands.iterator

    while (commandIterator.hasNext) {
      let command = commandIterator.stepNext

      match (command.toLowerCase()) {
        "install" => await install(mainSource)
        "installtest" => await install(testSource)
        "clean" => await clean()
        "run" => await run(commandIterator.stepNext)
        default => throw new InvalidCommandException("Invalid command '#command'")
      }
    }
  }

  public getInstallCommand(PackageSource source) -> String[] {
    if (!source) {
      throw new InvalidCommandException("No source found for installation")
    }

    let cmd = [
      "java",
      "-jar",
      "#{flatHome}/Flat/target/flatc.jar",
      source.source
    ]

    source.localDependencies.forEach({ cmd.addAll(["-l", _]) })

    cmd.addAll([
      "-install-dir", flatHome,
      "-main", source.mainClass,
      "-o", "#{source.outDirectory}/#{source.outFile}",
      "-target", "js"
    ])

    return cmd
  }

  public async install(PackageSource source) {
    let cmd = getInstallCommand(source)

    if (debug) {
      Console.writeLine(cmd[0] + " " + cmd.skip(1).map({ "\"#{_}\"" }).join(" "))
      return
    }

    await System.execute(cmd)
  }

  public async clean() {
    if (!await new File(outDirectory).delete()) {
      throw new Exception("Failed to clean directory '#outDirectory'")
    }
  }

  public async run(String script) {
    if (!package.scripts.containsKey(script)) {
      throw new InvalidScriptException("Script command '#script' is not defined")
    }

    let cmd = package.scripts[script]

    if (debug) {
      Console.writeLine(cmd)
      return
    }

    await System.execute(cmd)
  }
}