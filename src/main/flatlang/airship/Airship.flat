package "flatlang/airship"

import "flatlang/datastruct/HashMap"
import "flatlang/datastruct/HashSet"
import "flatlang/datastruct/Pair"
import "flatlang/json/JsonDeserializer"
import "flatlang/io/File"
import "flatlang/io/FileReader"
import "flatlang/fucli/FuCli"
import "flatlang/fucli/CliArg"
import "flatlang/git/Git"

import "flatlang/airship/services/InstallService"
import "flatlang/airship/services/UninstallService"
import "flatlang/airship/services/ReinstallService"
import "flatlang/airship/services/CleanService"
import "flatlang/airship/services/RunScriptService"

class {
  visible Package package
  visible String flatHome
  visible String outDirectory
  visible String outFile
  visible String source
  visible Bool debug
  visible PackageSource mainSource
  visible PackageSource testSource
  visible String flatJsonLocation
  visible File flatJsonFile
  visible File packageLocation
  visible String target

  visible CliArg targetArg = new CliArg("--target", ["-t"], count: 1)
  visible CliArg fileArg = new CliArg("--file", ["-f"], count: 1)
  visible CliArg linkArg = new CliArg("--link", new Array<String>(), minCount: 0, maxCount: 1)
  visible CliArg debugArg = new CliArg("--debug", ["-d"])
  visible CliArg quietArg = new CliArg("--quiet", ["-q"])
  visible CliArg installCommand = new CliArg("install", ["i"], minCount: 0)
  visible CliArg uninstallCommand = new CliArg("uninstall", new Array<String>(), minCount: 1)
  visible CliArg reinstallCommand = new CliArg("reinstall", new Array<String>(), minCount: 0)
  visible CliArg cleanCommand = new CliArg("clean", ["c"])
  visible CliArg runCommand = new CliArg("run", ["r"], minCount: 1)

  visible InstallService installService = new InstallService(this)
  visible UninstallService uninstallService = new UninstallService(this)
  visible ReinstallService reinstallService = new ReinstallService(this)
  visible CleanService cleanService = new CleanService(this)
  visible RunScriptService runScriptService = new RunScriptService(this)

  static HashMap<String, Airship> packageCache = new HashMap()

  public static async main(String[] args) {
    if (args.count < 2) {
      throw new Exception("Missing command")
    }

    let airship = await new Airship(args.skip(1)):run()
  }

  public construct(String[] args) {
    this(
      new FuCli([
        installCommand,
        uninstallCommand,
        reinstallCommand,
        cleanCommand,
        runCommand,
        targetArg,
        fileArg,
        linkArg,
        debugArg,
        quietArg
      ]):parse(args)
    )
  }

  getFlatJsonLocation(String location) -> String => null {
    if (!location) {
      return null
    }

    let file = new File(location)

    if (file.isDirectory || file.isSymbolicLink) {
      return location + "/flat.json"
    } else if (file.isFile) {
      return file.location
    } else {
      throw new InvalidFlatJsonException("Invalid flat.json location '#file.location'")
    }
  }

  public getFlatHome() -> String {
    if (System.getEnv("FLAT_HOME")) {
      return new File(System.getEnv("FLAT_HOME")).normalizedLocation
    } else {
      return new File("#{System.homeDirectory}/.flat").normalizedLocation
    }
  }

  public construct(visible FuCli cli) {
    flatJsonLocation = getFlatJsonLocation(fileArg.value) ?: "#{System.workingDirectory}/flat.json"
    debug = debugArg.enabled
    target = targetArg.value

    flatJsonFile = new File(flatJsonLocation)
    packageLocation = flatJsonFile.getParent()

    flatHome = getFlatHome()

    if (packageCache.containsKey(flatJsonFile.normalizedLocation)) {
      let airship = packageCache[flatJsonFile.normalizedLocation]

      target = target ?: airship.target
      package = airship.package
      mainSource = airship.mainSource
      testSource = airship.testSource
    } else {
      if (flatJsonFile.isFile) {
        let map = new JsonDeserializer().parseObject(flatJsonFile)

        let String defaultTarget = (String)map["defaultTarget"]
        target = target ?: defaultTarget

        if (target) {
          let parent = packageLocation.normalizedLocation
          let targetFileName = flatJsonFile.rootName + ".#{target}" + flatJsonFile.extension
          let targetFileLocation = parent + "/" + targetFileName
          let targetFlatJsonFile = new File(targetFileLocation)

          if (targetFlatJsonFile.isFile) {
            let targetMap = new JsonDeserializer().parseObject(targetFlatJsonFile)

            merge(targetMap, map)
          }
        }

        package = new Package(map)

        let sources = loadSources()
        mainSource = sources[0]
        testSource = sources[1]

        if (mainSource?.dependencies && testSource?.dependencies) {
          merge(mainSource.dependencies, testSource.dependencies)
        }

        if (!isStandardLibrary()) {
          if (mainSource?.dependencies) {
            mainSource.dependencies.add(new Pair("github:FlatLang/Standard-Library", "master"));
          }
          if (testSource?.dependencies) {
            testSource.dependencies.add(new Pair("github:FlatLang/Standard-Library", "master"));
          }
        }
      }

      packageCache[flatJsonFile.normalizedLocation] = this
    }
  }

  merge(
    HashMap<String, Object> source,
    HashMap<String, Object> dest
  ) {
    source.forEach((Pair<String, Object> pair) => {
      if (!dest.containsKey(pair.key)) {
        dest[pair.key] = pair.value
      }

      if (pair.value.class.isOfType(HashMap.class)) {
        let HashMap<String, Object> hashmap = (HashMap)pair.value
        let HashMap<String, Object> existingHashmap = (HashMap)dest[pair.key]
        merge(hashmap, existingHashmap)
      } else {
        dest[pair.key] = pair.value
      }
    })
  }

  loadSources() -> PackageSource[] {
    let main = package.main?.clone(
      outDirectory: validateOutDirectory(package.main.outDirectory ?: "dist"),
      outFile: package.main.outFile ?: "index.js",
      source: package.main.source ?: "src"
    )
    let test = package.test?.clone(
      outDirectory: validateOutDirectory(package.test.outDirectory ?: "dist"),
      outFile: package.test.outFile ?: "test.js",
      source: package.test.source ?: "src"
    )

    return [main, test]
  }

  validateOutDirectory(String location) => location {
    if (location.trim().count == 0) {
      throw new InvalidOutDirException("outDirectory cannot be empty")
    } else if (location.trim().startsWith(/[/\\.]/)) {
      throw new InvalidOutDirException("outDirectory cannot start with #location.first")
    } else if (location.contains(":/") || location.contains(":\\")) {
      throw new InvalidOutDirException("outDirectory cannot be absolute")
    }
  }

  async run() {
    if (!await checkFlatHome()) {
      return
    }

    for (command in cli.args.filter({ _.enabled })) {
      match (command) {
        installCommand => await installService.install()
        uninstallCommand => await uninstallService.uninstall()
        reinstallCommand => await reinstallService.reinstall()
        cleanCommand => await cleanService.clean()
        runCommand => await runScriptService.runScript(command.value)
      }
    }
  }

  public getDependencyLocation(Pair<String, String> dependency) -> String {
    if (dependency.value == "local") {
      return dependency.key
    } else if (dependency.key.toLowerCase().startsWith("github:")) {
      let fullRepoName = dependency.key.substring("github:".count).trim()
      let repoName = fullRepoName.substring(fullRepoName.lastIndexOf('/') + 1)
      return "#{flatHome}/packages/#{repoName}"
    } else {
      throw InvalidFlatJsonException("Invalid dependency #dependency")
    }
  }

  public getDependencyGitUrl(Pair<String, String> dependency) -> String {
    if (dependency.key.toLowerCase().startsWith("github:")) {
      let repoName = dependency.key.substring("github:".count).trim()
      return "https://GitHub.com/#{repoName}.git"
    } else {
      throw InvalidFlatJsonException("Invalid dependency #dependency")
    }
  }

  public async getDependenciesForSource(
    String package,
    String installationTarget,
    PackageSource source,
    Bool: download = true
  ) -> Array<Pair<String, String>> {
    return await getDependenciesForSource(
      package,
      installationTarget,
      source,
      download,
      new Array(),
      new HashSet()
    )
  }

  async getDependenciesForSource(
    String package,
    String installationTarget,
    PackageSource source,
    Bool download = true,
    Pair<String, String>[] dependencies,
    HashSet<String> dependenciesAdded
  ) -> Array<Pair<String, String>> {
    if (dependenciesAdded.contains(package)) {
      return dependencies
    }

    dependenciesAdded.add(package)

    if (!source.dependencies) {
      return dependencies
    }

    for (dependency in source.dependencies) {
      if (dependencies.none({ getDependencyLocation(_) == getDependencyLocation(dependency) })) {
        dependencies.add(dependency)
      }

      let dependencyPackageFile = new File(getDependencyLocation(dependency))

      if (!dependencyPackageFile.exists) {
        if (download) {
          await installService.install(
            getDependencyGitUrl(dependency),
            install: false,
            installDependencies: false
          );
        }

        if (!dependencyPackageFile.exists) {
          continue
        }
      }

      let airship = new Airship([
        "-f", dependencyPackageFile.normalizedLocation
      ])

      var packageSource

      match (installationTarget) {
        "main" => packageSource = airship.mainSource
        "test" => packageSource = airship.testSource ?: airship.mainSource
      }

      if (packageSource) {
        await airship.getDependenciesForSource(
          dependencyPackageFile.name,
          installationTarget,
          packageSource,
          download,
          dependencies,
          dependenciesAdded
        )
      }
    }

    return dependencies
  }

  public getSourceForPackage(String package) -> PackageSource {
    var source

    match (package) {
      "main" => source = mainSource
      "test" => source = testSource
      default => throw new InvalidCommandException("Invalid installation package '#package'")
    }

    return source
  }

  async checkFlatHome() => true {
    let flatHomeFile = new File("#{flatHome}")

    if (!flatHomeFile.isDirectory) {
      if (!flatHomeFile.getParent().isDirectory) {
        Console.writeLine("Invalid FLAT_HOME directory location '#{flatHome}'")
        return false
      }

      flatHomeFile.mkdirs()
    }
  }

  public async getGitOriginUrl() -> String => null {
    let url = await Git.getOriginUrl(silent: true)

    if (!url.endsWith(".git")) {
      return "#{url}.git"
    } else {
      return url
    }
  }

  isStandardLibrary() => packageLocation.name.equals("Standard-Library")
}