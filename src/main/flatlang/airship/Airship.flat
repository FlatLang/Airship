package "flatlang/airship"

import "flat/log/Logger"

import "flatlang/datastruct/HashMap"
import "flatlang/datastruct/HashSet"
import "flatlang/datastruct/Pair"
import "flatlang/regex/Pattern"
import "flatlang/json/JsonDeserializer"
import "flatlang/io/File"
import "flatlang/io/FileReader"
import "flatlang/fucli/FuCli"
import "flatlang/fucli/CliArg"
import "flatlang/git/Git"

import "flatlang/airship/services/SetupService"
import "flatlang/airship/services/DependencyService"
import "flatlang/airship/services/InstallService"
import "flatlang/airship/services/UninstallService"
import "flatlang/airship/services/ReinstallService"
import "flatlang/airship/services/UpdateService"
import "flatlang/airship/services/CleanService"
import "flatlang/airship/services/RunScriptService"

import "flatlang/regex/RegexStringExtensions"

class {
  visible Package package
  visible String flatHome
  visible String outFile
  visible String source
  visible Bool debug
  visible PackageSource mainSource
  visible PackageSource testSource
  visible String flatJsonLocation
  visible File flatJsonFile
  visible File packageLocation
  visible String target

  visible CliArg targetArg = CliArg("--target", ["-t"], count: 1)
  visible CliArg targetRuntimeArg = CliArg("--target-runtime", ["--runtime", "-r"], count: 1)
  visible CliArg fileArg = CliArg("--file", ["-f"], count: 1)
  visible CliArg linkArg = CliArg("--link", Array<String>(), minCount: 0, maxCount: 1)
  visible CliArg debugArg = CliArg("--debug", ["-d"])
  visible CliArg quietArg = CliArg("--quiet", ["-q"])
  visible CliArg setupCommand = CliArg("setup")
  visible CliArg installCommand = CliArg("install", ["i"], minCount: 0)
  visible CliArg uninstallCommand = CliArg("uninstall", Array<String>(), minCount: 1)
  visible CliArg reinstallCommand = CliArg("reinstall", Array<String>(), minCount: 0)
  visible CliArg updateCommand = CliArg("update", ["u"], minCount: 0)
  visible CliArg cleanCommand = CliArg("clean", ["c"])
  visible CliArg runCommand = CliArg("run", ["r"], minCount: 1)

  visible DependencyService dependencyService = DependencyService(this)
  visible InstallService installService = InstallService(this, dependencyService)
  visible UninstallService uninstallService = UninstallService(this)
  visible ReinstallService reinstallService = ReinstallService(this)
  visible UpdateService updateService = UpdateService(this, dependencyService)
  visible CleanService cleanService = CleanService(this)
  visible RunScriptService runScriptService = RunScriptService(this)
  visible SetupService setupService = SetupService(this, dependencyService, updateService)

  let static HashMap<String, Airship> packageCache = HashMap()

  let static Logger log = Logger(Airship.class)

  public static async main(String[] args) {
    try {
      if (args.count < 2) {
        throw Exception("Missing command")
      }

      Airship(args.skip(1)):run()
    } catch (Exception e) {
      log.error(e.message)
      System.exit(1)
    }
  }

  public construct(
    String[] args,
    Airship parent = null
  ) {
    this(
      FuCli([
        setupCommand,
        installCommand,
        uninstallCommand,
        reinstallCommand,
        updateCommand,
        cleanCommand,
        runCommand,
        targetArg,
        targetRuntimeArg,
        fileArg,
        linkArg,
        debugArg,
        quietArg
      ]):parse(args),
      parent
    )
  }

  public construct(
    visible FuCli cli,
    visible Airship parent = null
  ) {
    if (debugArg.enabled) {
      quietArg.enabled = true
    }

    if (quietArg.enabled) {
      Logger.DEFAULT_LOGGING_LEVEL = Logger.OFF
    }

    flatJsonLocation = getFlatJsonLocation(fileArg.value) ?: "#{System.workingDirectory}/flat.json"
    debug = debugArg.enabled
    target = targetArg.value

    flatJsonFile = File(flatJsonLocation)
    packageLocation = flatJsonFile.getParent()

    flatHome = getFlatHome()

    if (packageCache.containsKey(flatJsonFile.normalizedLocation)) {
      let airship = packageCache[flatJsonFile.normalizedLocation]

      target = target ?: airship.target
      package = airship.package
      mainSource = airship.mainSource
      testSource = airship.testSource
    } else {
      if (flatJsonFile.isFile) {
        let map = JsonDeserializer().parseObject(flatJsonFile)

        let String defaultTarget = (String)map["defaultTarget"]
        target = target ?: defaultTarget

        if (let targetFlatJsonFile = getFlatJsonOverride(packageLocation)) {
          let targetMap = JsonDeserializer().parseObject(targetFlatJsonFile)

          merge(targetMap, map)
        }

        package = Package(map)

        let sources = loadSources()
        mainSource = sources[0]
        testSource = sources[1]

        if (mainSource?.dependencies && testSource?.dependencies) {
          merge(mainSource.dependencies, testSource.dependencies)
        }

        if (!isCoreLibrary()) {
          if (mainSource?.dependencies) {
            mainSource.dependencies.add(Pair("github:FlatLang/Flat-Core", "master"));
          }
          if (testSource?.dependencies) {
            testSource.dependencies.add(Pair("github:FlatLang/Flat-Core", "master"));
          }
        }
      }

      packageCache[flatJsonFile.normalizedLocation] = this
    }
  }

  getFlatJsonLocation(String location) -> String => null {
    if (!location) {
      return null
    }

    let file = File(location)

    return if (file.isDirectory || file.isSymbolicLink) {
      location + "/flat.json"
    } else if (file.isFile) {
      file.location
    } else {
      throw InvalidFlatJsonException("Invalid flat.json location '#file.location'")
    }
  }

  public getFlatHome() -> String {
    return if (System.getEnv("FLAT_HOME")) {
      File(System.getEnv("FLAT_HOME")).normalizedLocation
    } else {
      File("#{System.homeDirectory}/.flat").normalizedLocation
    }
  }

  getFlatJsonOverride(File packageLocation) -> File => null {
    if (target) {
      let override = getFlatJsonOverrideForTarget(packageLocation, target)

      return if (override) {
        override
      } else if (target == "es6") {
        getFlatJsonOverrideForTarget(packageLocation, "js")
      }
    }
  }

  getFlatJsonOverrideForTarget(File packageLocation, String target) -> File => null {
    let parent = packageLocation.normalizedLocation
    let targetFileName = flatJsonFile.rootName + ".#{target}" + flatJsonFile.extension
    let targetFileLocation = parent + "/" + targetFileName
    let targetFlatJsonFile = File(targetFileLocation)

    if (targetFlatJsonFile.isFile) {
      return targetFlatJsonFile
    }
  }

  merge(
    HashMap<String, Object> source,
    HashMap<String, Object> dest
  ) {
    source.forEach((Pair<String, Object> pair) => {
      if (!dest.containsKey(pair.key)) {
        dest[pair.key] = pair.value
      }

      if (pair.value.class.isOfType(HashMap.class)) {
        let HashMap<String, Object> hashmap = (HashMap)pair.value
        let HashMap<String, Object> existingHashmap = (HashMap)dest[pair.key]
        merge(hashmap, existingHashmap)
      } else {
        dest[pair.key] = pair.value
      }
    })
  }

  loadSources() -> PackageSource[] {
    let main = package.main?.clone(
      outDirectory: validateOutDirectory(package.main.outDirectory ?: "dist"),
      outFile: package.main.outFile ?: "index.js",
      source: package.main.source ?: "src"
    )
    let test = package.test?.clone(
      outDirectory: validateOutDirectory(package.test.outDirectory ?: "dist"),
      outFile: package.test.outFile ?: "test.js",
      source: package.test.source ?: "src"
    )

    return [main, test]
  }

  validateOutDirectory(String location) => location {
    if (location.trim().count == 0) {
      throw InvalidOutDirException("outDirectory cannot be empty")
    } else if (location.trim().startsWith(/[/\\.]/)) {
      throw InvalidOutDirException("outDirectory cannot start with #location.first")
    } else if (location.contains(":/") || location.contains(":\\")) {
      throw InvalidOutDirException("outDirectory cannot be absolute")
    }
  }

  async run() {
    if (!checkFlatHome()) {
      return
    }

    for (command in cli.args.filter({ _.enabled })) {
      match (command) {
        setupCommand => setupService.setup()
        installCommand => installService.install()
        uninstallCommand => uninstallService.uninstall()
        reinstallCommand => reinstallService.reinstall()
        updateCommand => updateService.update()
        cleanCommand => cleanService.clean()
        runCommand => runScriptService.runScript(command.value)
      }
    }
  }

  public getSourceForPackage(String package) -> PackageSource {
    return match (package) {
      "main" => mainSource
      "test" => testSource
      default => throw InvalidCommandException("Invalid installation package '#package'")
    }
  }

  async checkFlatHome() => true {
    let flatHomeFile = File("#{flatHome}")

    if (!flatHomeFile.isDirectory) {
      if (!flatHomeFile.getParent().isDirectory) {
        log.error("Invalid FLAT_HOME directory location '#{flatHome}'")
        return false
      }

      flatHomeFile.mkdirs()
    }
  }

  public async getGitOriginUrl() -> String => null {
    let response = Git.getOriginUrl(silent: true)

    if (response.success) {
      let url = response.value

      return if (!url.endsWith(".git")) {
        "#{url}.git"
      } else {
        url
      }
    }
  }

  getRootParent() -> Airship => this {
    if (parent) {
      return parent.getRootParent()
    }
  }

  isCoreLibrary() => getRootParent().packageLocation.name.equals("Flat-Core")

  public propagateArgs(String[] args) {
    if (target) {
      args.addAll(["-t", target])
    }
    if (targetRuntimeArg.enabled) {
      args.addAll(["-r", targetRuntimeArg.value])
    }
    if (quietArg.enabled) {
      args.add("-q")
    }
  }
}