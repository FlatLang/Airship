package "flatlang/airship"

import "flatlang/datastruct/HashMap"
import "flatlang/datastruct/Pair"
import "flatlang/json/JsonDeserializer"
import "flatlang/io/File"
import "flatlang/io/FileReader"
import "flatlang/fucli/FuCli"
import "flatlang/fucli/CliArg"

class {
  visible Package package
  visible String flatHome
  visible String outDirectory
  visible String outFile
  visible String source
  visible Bool debug
  visible PackageSource mainSource
  visible PackageSource testSource
  visible String flatJsonLocation
  visible File flatJsonFile
  visible String target
  visible Int[] exitCodes = new Array<Int>()

  visible CliArg targetArg = new CliArg("--target", ["-t"], count: 1)
  visible CliArg fileArg = new CliArg("--file", ["-f"], count: 1)
  visible CliArg debugArg = new CliArg("--debug", ["-d"])
  visible CliArg installCommand = new CliArg("install", ["i"], minCount: 0)
  visible CliArg cleanCommand = new CliArg("clean", ["c"])
  visible CliArg runCommand = new CliArg("run", ["r"], minCount: 1)

  let visible static String FLAT_REPO = "FlatLang/Flat"

  public static async main(String[] args) {
    if (args.count < 2) {
      throw new Exception("Missing command")
    }

    let airship = await new Airship(args.skip(1)):run()

    let errorCodes = airship.exitCodes.filter({ _ != 0 })

    if (errorCodes.isNotEmpty) {
      Console.log("Encountered error code#{errorCodes.count == 1 ? "" : 's'}: #{errorCodes.join(", ")}")
      System.exit(1)
    }
  }

  public construct(String[] args) {
    this(
      new FuCli([
        installCommand,
        cleanCommand,
        runCommand,
        targetArg,
        fileArg,
        debugArg
      ]):parse(args)
    )
  }

  public construct(visible FuCli cli) {
    flatJsonLocation = fileArg.value ?: "#{System.workingDirectory}/flat.json"
    debug = debugArg.enabled

    flatJsonFile = new File(flatJsonLocation)
    let map = new JsonDeserializer().parseObject(flatJsonFile)

    let String defaultTarget = (String)map["defaultTarget"]
    target = targetArg.value ?: defaultTarget

    if (target) {
      let parent = flatJsonFile.getParent().normalizedLocation
      let targetFileName = flatJsonFile.rootName + ".#{target}" + flatJsonFile.extension
      let targetFileLocation = parent + "/" + targetFileName
      let targetFlatJsonFile = new File(targetFileLocation)

      if (targetFlatJsonFile.isFile) {
        let targetMap = new JsonDeserializer().parseObject(targetFlatJsonFile)

        merge(targetMap, map)
      }
    }

    package = new Package(map)

    flatHome = System.getEnv("FLAT_HOME")

    let sources = loadSources()
    mainSource = sources[0]
    testSource = sources[1]

    if (mainSource?.dependencies && testSource?.dependencies) {
      merge(mainSource.dependencies, testSource.dependencies)
    }
  }

  merge(
    HashMap<String, Object> source,
    HashMap<String, Object> dest
  ) {
    source.forEach((Pair<String, Object> pair) => {
      if (!dest.containsKey(pair.key)) {
        dest[pair.key] = pair.value
      }

      if (pair.value.class.isOfType(HashMap.class)) {
        let HashMap<String, Object> hashmap = (HashMap)pair.value
        let HashMap<String, Object> existingHashmap = (HashMap)dest[pair.key]
        merge(hashmap, existingHashmap)
      } else {
        dest[pair.key] = pair.value
      }
    })
  }

  loadSources() -> PackageSource[] {
    let main = package.main?.clone(
      outDirectory: validateOutDirectory(package.main.outDirectory ?: "dist"),
      outFile: package.main.outFile ?: "index.js",
      source: package.main.source ?: "src"
    )
    let test = package.test?.clone(
      outDirectory: validateOutDirectory(package.test.outDirectory ?: "dist"),
      outFile: package.test.outFile ?: "test.js",
      source: package.test.source ?: "src"
    )

    return [main, test]
  }

  validateOutDirectory(String location) => location {
    if (location.trim().count == 0) {
      throw new InvalidOutDirException("outDirectory cannot be empty")
    } else if (location.trim().startsWith(/[/\\.]/)) {
      throw new InvalidOutDirException("outDirectory cannot start with #location.first")
    } else if (location.contains(":/") || location.contains(":\\")) {
      throw new InvalidOutDirException("outDirectory cannot be absolute")
    }
  }

  async run() {
    for (command in cli.args.filter({ _.enabled })) {
      match (command) {
        installCommand => exitCodes.addAll(await install())
        cleanCommand => await clean()
        runCommand => exitCodes.add(await runScript(command.value))
      }
    }
  }

  public getInstallCommand(PackageSource source) -> String[] {
    if (!source) {
      throw new InvalidCommandException("No source found for installation")
    }

    let cmd = [
      "java",
      "-jar",
      "#{flatHome}/bin/flatc.jar",
      source.source,
      "-install-dir", flatHome,
      "-o", "#{source.outDirectory}/#{source.outFile}",
      "-target", target
    ]

    source.localDependencies.forEach({ cmd.addAll(["-l", _]) })

    if (source.mainClass) {
      cmd.addAll(["-main", source.mainClass])
    } else {
      cmd.add("-library")
    }

    return cmd
  }

  public async install() -> Int[] {
    let exitCodes = new Array<Int>()

    if (installCommand.values.isEmpty) {
      return exitCodes:add(await install("main"))
    }

    for (package in installCommand.values) {
      exitCodes.add(await install(package))
    }

    return exitCodes
  }

  async install(String package) -> Int {
    if (package == "flat") {
      return await installFlat()
    } else {
      return await installLocalPackage(package)
    }
  }

  async installLocalPackage(String package) -> Int {
    var source
    match (package) {
      "main" => source = mainSource
      "test" => source = testSource
      default => throw new InvalidCommandException("Invalid installation package '#package'")
    }

    let cmd = getInstallCommand(source)

    if (debug) {
      Console.writeLine(cmd[0] + " " + cmd.skip(1).map({ "\"#{_}\"" }).join(" "))
      return 0
    }

    return await System.execute(cmd)
  }

  async installFlat() -> Int {


    return 0
  }

  public async clean()  {
    if (!await new File(outDirectory).delete()) {
      throw new Exception("Failed to clean directory '#outDirectory'")
    }
  }

  public async runScript(String script) -> Int {
    if (!package.scripts.containsKey(script)) {
      throw new InvalidScriptException("Script command '#script' is not defined")
    }

    let cmd = package.scripts[script]

    if (debug) {
      Console.writeLine(cmd)
      return 0
    }

    return await System.execute(cmd)
  }
}