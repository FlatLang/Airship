package flatlang/airship

import flat/log/Logger

import flatlang/datastruct/HashMap
import flatlang/datastruct/HashSet
import flatlang/datastruct/Pair
import flatlang/regex/Pattern
import flatlang/json/JsonDeserializer
import flatlang/io/File
import flatlang/io/FileReader
import flatlang/fucli/FuCli
import flatlang/fucli/CliArg
import flatlang/git/Git
import flatlang/time/Timer

import flatlang/airship/services/SetupService
import flatlang/airship/services/DependencyService
import flatlang/airship/services/InstallService
import flatlang/airship/services/UninstallService
import flatlang/airship/services/ReinstallService
import flatlang/airship/services/UpdateService
import flatlang/airship/services/CleanService
import flatlang/airship/services/RunScriptService
import flatlang/airship/services/InitService
import flatlang/airship/services/CreateService

import flatlang/regex/RegexStringExtensions

class {
  visible static String flatHome = getFlatHome()

  visible Package package
  visible String outFile
  visible Bool debug
  visible PackageSource mainSource
  visible PackageSource testSource
  visible String flatJsonLocation
  visible File flatJsonFile
  visible File packageLocation
  visible String target

  visible CliArg targetArg = CliArg("--target", ["-t"], count: 1)
  visible CliArg targetRuntimeArg = CliArg("--target-runtime", ["--runtime", "-r"], count: 1)
  visible CliArg fileArg = CliArg("--file", ["-f"], count: 1)
  visible CliArg linkArg = CliArg("--link", minCount: 0, maxCount: 1)
  visible CliArg debugArg = CliArg("--debug", ["-d"])
  visible CliArg quietArg = CliArg("--quiet", ["-q"])
  visible CliArg setupCommand = CliArg("setup")
  visible CliArg installCommand = CliArg("install", ["i"], minCount: 0)
  visible CliArg uninstallCommand = CliArg("uninstall", minCount: 1)
  visible CliArg reinstallCommand = CliArg("reinstall", minCount: 0)
  visible CliArg updateCommand = CliArg("update", ["u"], minCount: 0)
  visible CliArg cleanCommand = CliArg("clean", ["c"])
  visible CliArg runCommand = CliArg("run", ["r"], minCount: 1)
  visible CliArg initCommand = CliArg("init")
  visible CliArg createCommand = CliArg("create", minCount: 1)

  visible DependencyService dependencyService = DependencyService(this)
  visible InstallService installService = InstallService(this, dependencyService)
  visible UninstallService uninstallService = UninstallService(this)
  visible ReinstallService reinstallService = ReinstallService(this)
  visible UpdateService updateService = UpdateService(this, dependencyService)
  visible CleanService cleanService = CleanService(this)
  visible RunScriptService runScriptService = RunScriptService(this)
  visible SetupService setupService = SetupService(this, dependencyService, updateService)
  visible InitService initService = InitService(this)
  visible CreateService createService = CreateService(this)

  let static HashMap<String, Airship> packageCache = HashMap()

  let static Logger log = Logger(Airship.class)

  public static async main(String[] args) {
    try {
      if (args.count < 2) {
        throw Exception("Missing command")
      }

      Airship(args.skip(1)):run()
    } catch (Exception e) {
      log.error(e.message)
      System.exit(1)
    }
  }

  public construct(
    File packageLocationFile,
    Airship parent = null
  ) {
    this(packageLocationFile.normalizedLocation, parent)
  }

  public construct(
    String packageLocation,
    Airship parent = null
  ) {
    this(["-f", packageLocation], parent)
  }

  public construct(
    String[] args,
    Airship parent = null
  ) {
    this(
      FuCli([
        setupCommand,
        installCommand,
        uninstallCommand,
        reinstallCommand,
        updateCommand,
        cleanCommand,
        runCommand,
        initCommand,
        createCommand,
        targetArg,
        targetRuntimeArg,
        fileArg,
        linkArg,
        debugArg,
        quietArg
      ]):parse(args),
      parent
    )
  }

  public construct(
    visible FuCli cli,
    visible Airship parent = null
  ) {
    if (debugArg.enabled) {
      quietArg.enabled = true
    }

    if (quietArg.enabled) {
      Logger.DEFAULT_LOGGING_LEVEL = Logger.OFF
    }

    flatJsonLocation = getFlatJsonLocation(fileArg.value)
    debug = debugArg.enabled
    target = targetArg.value

    flatJsonFile = File(flatJsonLocation)
    packageLocation = flatJsonFile.getParent()

    if (packageCache.containsKey(flatJsonFile.normalizedLocation)) {
      let airship = packageCache[flatJsonFile.normalizedLocation]

      target = target ?: airship.target
      package = airship.package
      mainSource = airship.mainSource
      testSource = airship.testSource
    } else {
      if (flatJsonFile.isFile) {
        log.trace("Parsing \"#{flatJsonFile.normalizedLocation}\" ...")
        let timer = Timer():start()
        let map = JsonDeserializer().parseObject(flatJsonFile)
        timer.stop()
        log.trace("Parsing \"#{flatJsonFile.normalizedLocation}\" took #{timer.duration}ms")

        let String defaultTarget = (String)map["defaultTarget"]
        target = target ?: defaultTarget

        if (let targetFlatJsonFile = getFlatJsonOverride(packageLocation)) {
          let targetMap = JsonDeserializer().parseObject(targetFlatJsonFile)

          merge(targetMap, map)
        }

        package = Package(map)

        let sources = loadSources()
        mainSource = sources[0]
        testSource = sources[1]

        if (mainSource?.dependencies && testSource?.dependencies) {
          merge(mainSource.dependencies, testSource.dependencies)
        }

        if (mainSource && testSource) {
          merge(mainSource.defaultExports, testSource.defaultExports)
        }

        if (!isCoreLibrary()) {
          log.trace("Adding Flat-Core implicit dependency")

          if (mainSource?.dependencies) {
            mainSource.dependencies.add(GitHubDependency("github:FlatLang/Flat-Core", "master"));
          }
          if (testSource?.dependencies) {
            testSource.dependencies.add(GitHubDependency("github:FlatLang/Flat-Core", "master"));
          }
        } else {
          log.trace("Skipping Flat-Core implicit dependency")
        }
      }

      packageCache[flatJsonFile.normalizedLocation] = this
    }
  }

  getFlatJsonLocation(String location) -> String {
    if (!location) {
      return File("#{System.workingDirectory}/flat.json").normalizedLocation
    }

    let file = File(location)

    return if (file.isDirectory || file.isSymbolicLink) {
      file.normalizedLocation + "/flat.json"
    } else if (file.isFile) {
      file.normalizedLocation
    } else {
      throw InvalidFlatJsonException("Invalid flat.json location '#file.location'")
    }
  }

  public static getFlatHome() -> String {
    return if (System.getEnv("FLAT_HOME")) {
      File(System.getEnv("FLAT_HOME")).normalizedLocation
    } else {
      File("#{System.homeDirectory}/.flat").normalizedLocation
    }
  }

  getFlatJsonOverride(File packageLocation) -> File => null {
    if (target) {
      let override = getFlatJsonOverrideForTarget(packageLocation, target)

      return if (override) {
        override
      } else if (target == "es6") {
        getFlatJsonOverrideForTarget(packageLocation, "js")
      }
    }
  }

  getFlatJsonOverrideForTarget(File packageLocation, String target) -> File => null {
    let parent = packageLocation.normalizedLocation
    let targetFileName = flatJsonFile.rootName + ".#{target}" + flatJsonFile.extension
    let targetFileLocation = parent + "/" + targetFileName
    let targetFlatJsonFile = File(targetFileLocation)

    if (targetFlatJsonFile.isFile) {
      return targetFlatJsonFile
    }
  }

  merge(
    HashMap<String, Object> source,
    HashMap<String, Object> dest
  ) {
    source.forEach((Pair<String, Object> pair) => {
      if (!dest.containsKey(pair.key)) {
        dest[pair.key] = pair.value
      }

      if (pair.value.class.isOfType(HashMap.class)) {
        let HashMap<String, Object> hashmap = (HashMap)pair.value
        let HashMap<String, Object> existingHashmap = (HashMap)dest[pair.key]
        merge(hashmap, existingHashmap)
      } else {
        dest[pair.key] = pair.value
      }
    })
  }

  merge(
    Object[] source,
    Object[] dest
  ) {
    source.forEach((value) => {
      if (!dest.contains(value)) {
        dest.add(value)
      }
    })
  }

  loadSources() -> PackageSource[] {
    let main = package.main?.clone(
      outDirectory: validateOutDirectory(package.main.outDirectory ?: "dist"),
      outFile: package.main.outFile ?: "index.js",
      source: package.main.source ?: "src"
    )
    let test = package.test?.clone(
      outDirectory: validateOutDirectory(package.test.outDirectory ?: "dist"),
      outFile: package.test.outFile ?: "test.js",
      source: package.test.source ?: "src"
    )

    return [main, test]
  }

  validateOutDirectory(String location) => location {
    if (location.trim().count == 0) {
      throw InvalidOutDirException("outDirectory cannot be empty")
    } else if (location.trim().startsWith(/[/\\.]/)) {
      throw InvalidOutDirException("outDirectory cannot start with #location.first")
    } else if (location.contains(":/") || location.contains(":\\")) {
      throw InvalidOutDirException("outDirectory cannot be absolute")
    }
  }

  async run() {
    if (!checkFlatHome()) {
      return
    }

    for (command in cli.args.filter({ _.enabled })) {
      match (command) {
        setupCommand => setupService.setup()
        installCommand => installService.install()
        uninstallCommand => uninstallService.uninstall()
        reinstallCommand => reinstallService.reinstall()
        updateCommand => updateService.update()
        cleanCommand => cleanService.clean()
        runCommand => runScriptService.runScript(command.value)
        initCommand => initService.init()
        createCommand => createService.create(command.value, command.values.skip(1))
      }
    }
  }

  public getSourceForPackage(String package, PackageSource defaultSource = null) -> PackageSource {
    return match (package) {
      "main" => mainSource
      "test" => testSource
      default => {
        if (defaultSource) {
          return defaultSource
        }

        throw InvalidCommandException("Invalid installation package '#package'")
      }
    }
  }

  async checkFlatHome() => true {
    let flatHomeFile = File("#{flatHome}")

    if (!flatHomeFile.isDirectory) {
      if (!flatHomeFile.getParent().isDirectory) {
        log.error("Invalid FLAT_HOME directory location '#{flatHome}'")
        return false
      }

      flatHomeFile.mkdirs()
    }
  }

  public async getGitOriginUrl() -> String => null {
    let response = Git.getOriginUrl(silent: true)

    if (response.success) {
      let url = response.value

      return if (!url.endsWith(".git")) {
        "#{url}.git"
      } else {
        url
      }
    }
  }

  getRootParent() -> Airship => this {
    if (parent) {
      return parent.getRootParent()
    }
  }

  isCoreLibrary() => getRootParent().packageLocation.normalizedLocation.endsWith(".flat/packages/Flat-Core")

  public propagateArgs(String[] args) {
    if (target) {
      args.addAll(["-t", target])
    }
    if (targetRuntimeArg.enabled) {
      args.addAll(["-r", targetRuntimeArg.value])
    }
    if (quietArg.enabled) {
      args.add("-q")
    }
  }
}