package flatlang/airship/services

import flatlang/datastruct/HashMap
import flat/log/Logger

import flatlang/io/File
import flatlang/git/Git
import flatlang/airship/Airship
import flatlang/airship/PackageSource
import flatlang/airship/Dependency
import flatlang/airship/GitHubDependency
import flatlang/airship/LocalDependency
import flatlang/airship/InvalidCommandException
import flatlang/airship/InvalidFlatJsonException
import flatlang/airship/ExecutionFailureException

class {
  let static Logger log = Logger(InstallService.class)

  public construct(
    private Airship airship,
    private DependencyService dependencyService
  ) {}

  public async install() {
    if (airship.installCommand.values.isEmpty) {
      if (airship.linkArg.enabled) {
        if (let gitUrl = airship.getGitOriginUrl()) {
          airship.linkArg.value = "."
          installAndLink(gitUrl)
          return
        } else {
          throw InvalidCommandException("#{System.workingDirectory} is not a git repository")
        }
      }
      install("main", install: true)
    } else {
      for (package in airship.installCommand.values) {
        install(package, install: true)
      }
    }
  }

  public async install(
    String package,
    Bool: install = false,
    Bool: installDependencies = true
  ) {
    if (airship.linkArg.enabled) {
      installAndLink(package)
    } else if (package.endsWith(".git")) {
      installGitPackage(GitHubDependency(package, "master"), install, installDependencies)
    } else {
      installLocalPackage(package)
    }
  }

  public async getInstallCommand(String installationTarget, PackageSource source) -> String[] {
    let currentDependency = Dependency(airship.packageLocation.normalizedLocation)

    let sourceLocations = dependencyService.getDependencySourceLocations(currentDependency, installationTarget)
    let excludeSources = dependencyService.getDependencyExclusions(currentDependency, installationTarget)
    let excludeSource = installationTarget == "test" ? null : dependencyService.getDependencySourceGlobLocation(currentDependency, "test")
    let canonicalSourceLocations = Array<String>()

    for (location in sourceLocations) {
      canonicalSourceLocations.add(File(location).getCanonicalPath())
    }

    let cmd = [
      "java",
      "-jar",
      "#{Airship.flatHome}/packages/Flat/target/flatc.jar",
    ]

    cmd.addAll(sourceLocations)

    cmd.addAll([
      "-install-dir", "#{Airship.flatHome}/packages",
      "-o", "#{airship.packageLocation.normalizedLocation}/#{source.outDirectory}/#{source.outFile}"
    ])

    if (airship.target) {
      cmd.addAll(["-target", airship.target])
    }
    if (airship.targetRuntimeArg.enabled) {
      cmd.addAll(["-target-runtime", airship.targetRuntimeArg.value])
    }

    excludeSources.forEach({ cmd.addAll(["-x", _]) })

    if (excludeSource) {
      cmd.addAll(["-x", excludeSource])
    }

    let response = dependencyService.getDependenciesForSource(installationTarget, installationTarget, source)
    let topLevelDependencies = dependencyService.getDependenciesForSource(installationTarget, installationTarget, source, recursive: false)

    let dependencyLocations = HashMap<Dependency, Array<String>>()
    let excludeLocations = HashMap<Dependency, Array<String>>()

    for (dependency in response.dependencies) {
      if (!dependencyLocations.containsKey(dependency)) {
        let dependencySourceLocations = dependencyService.getDependencySourceLocations(dependency, installationTarget)

        dependencyLocations[dependency] = Array()

        for (src in dependencySourceLocations) {
           dependencyLocations[dependency].add(File(src).getCanonicalPath())
        }
      }
    }

    response.dependencies
      .filter({ dependencyLocations[_].none(l => canonicalSourceLocations.contains(l)) })
      .forEach((dependency) => {
        dependencyService
          .getDependencySourceLocations(dependency)
          .forEach({ cmd.addAll(["-l", _]) })

        dependencyService
          .getDependencyExclusions(dependency, installationTarget)
          .forEach({ cmd.addAll(["-x", _]) })

        let dependencyExcludeSource = installationTarget == "test" ? null : dependencyService.getDependencySourceGlobLocation(dependency, "test")

        if (dependencyExcludeSource) {
          cmd.addAll(["-x", dependencyExcludeSource])
        }
      })

    topLevelDependencies.dependencies
      .filter({ dependencyLocations[_].none(l => canonicalSourceLocations.contains(l)) })
      .forEach((dependency) => {
        let childship = dependency.airship
        let dependencySource = childship.getSourceForPackage(installationTarget, childship.package.defaultSource)

        dependencySource?.defaultExports
          .filter({ !_.staticImport })
          .forEach({ cmd.addAll(["-default-import", _.location]) })

        dependencySource?.defaultExports
          .filter({ _.staticImport })
          .forEach({ cmd.addAll(["-default-static-import", _.location]) })
      })

    if (source.mainClass) {
      cmd.addAll(["-main", source.mainClass])
    } else {
      cmd.add("-library")
    }

    return cmd
  }

  async installLocalPackage(String package) {
    log.debug("Installing local package #{airship.packageLocation.normalizedLocation} with target \"#package\"")

    let source = airship.getSourceForPackage(package, airship.parent ? airship.package.defaultSource : null)

    if (!source) {
      log.debug("No source for local package #{airship.packageLocation.normalizedLocation}. Skipping installation")
      return
    }

    installDependencies(package, source)
    let cmd = getInstallCommand(package, source)

    if (airship.debug) {
      Console.writeLine(cmd[0] + " " + cmd.skip(1).map({ "\"#{_}\"" }).join(" "))
      return
    }

    log.debug("Executing command: #cmd")

    let response = System.execute(cmd, silent: airship.quietArg.enabled)

    if (response.exitCode != 0) {
      throw ExecutionFailureException("Compilation failed")
    }
  }

  public async installGitPackage(
    GitHubDependency dependency,
    Bool: build = true,
    Bool: install = true,
    Bool: installDependencies = true
  ) {
    if (!dependencyService.isDependencyInstalled(dependency)) {
      dependencyService.downloadDependency(dependency)
    }

    postInstallPackage(
      File(dependency.getLocation()),
      build,
      install,
      installDependencies
    )
  }

  async installAndLink(String url) {
    let start = url.lastIndexOf('/') + 1
    let end = url.lastIndexOf('.')

    if (start > end) {
      throw InvalidFlatJsonException("Invalid repo url '#url'")
    }

    let packageName = url.substring(start, end)
    let flatPackageDir = File("#{Airship.flatHome}/packages/#{packageName}")

    flatPackageDir.symbolicLinkTo(File("#{System.workingDirectory}/#{airship.linkArg.value}"))

    postInstallPackage(flatPackageDir, install: false)
  }

  async installDependencies(String package, PackageSource source, Bool install = false) {
    let response = dependencyService.getDependenciesForSource(package, package, source)

    for (dependency in response.dependencies.filter({ _.class.isOfType(GitHubDependency.class) })) {
      installGitPackage(
        (GitHubDependency)dependency,
        build: response.dependenciesDownloaded.contains(dependency),
        install: false,
        installDependencies: false
      )
    }
  }

  async postInstallPackage(
    File flatPackageDir,
    Bool: build = true,
    Bool: install = true,
    Bool: installDependencies = true
  ) {
    let args = [
      "-f", flatPackageDir.normalizedLocation
    ]

    airship.propagateArgs(args)

    let childship = Airship(args, airship)

    if (build && childship.package?.scripts.containsKey("build")) {
      childship.runScriptService.runScript("build")
    }

    if (childship.package?.mainSource) {
      if (installDependencies) {
        childship.installService.installDependencies(flatPackageDir.name, childship.package.mainSource)
      }
      if (install) {
        childship.installService.install()
      }
    }
  }
}