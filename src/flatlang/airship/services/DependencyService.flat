package flatlang/airship/services

import flat/log/Logger

import flatlang/airship/Airship
import flatlang/airship/PackageSource
import flatlang/datastruct/HashSet
import flatlang/io/File
import flatlang/git/Git
import flatlang/airship/InvalidFlatJsonException
import flatlang/airship/ExecutionFailureException
import flatlang/airship/Dependency
import flatlang/airship/GitHubDependency
import flatlang/airship/LocalDependency
import flatlang/airship/NpmDependency

class {
  let static Logger log = Logger(DependencyService.class)

  public construct(
    private Airship airship
  ) {}

  getPackageNameFromGitUrl(String url) => url.substring(url.lastIndexOf('/') + 1, url.lastIndexOf('.'))

  public getDependencySourceLocations(Dependency dependency, String installationTarget = "main") -> String[] {
    let baseLocation = dependency.getLocation()

    if (!baseLocation) {
      return Array<String>()
    }

    return dependency.getSourcesForInstallation(installationTarget)
      .map({ _?.source ?: "src" })
      .map({ "#{baseLocation}/#{_}" })
  }

  public getDependencySourceLocation(Dependency dependency, String installationTarget = "main") -> String {
    let baseLocation = dependency.getLocation()

    if (!baseLocation) {
      return null
    }

    let source = dependency.airship.getSourceForPackage(installationTarget, dependency.airship.package.defaultSource)

    if (source?.source) {
      return "#{baseLocation}/#{source.source}"
    } else {
      return null
    }
  }

  public getDependencySourceGlobLocation(Dependency dependency, String installationTarget = "main") -> String {
    if (let location = getDependencySourceLocation(dependency, installationTarget)) {
      let glob = location.contains("*")
      log.trace("Checking location for glob: #{location}: #{glob}")
      if (glob) {
        return location
      }
    }

    return null
  }

  public getDependencyExclusions(Dependency dependency, String installationTarget = "main") -> String[] {
    let baseLocation = dependency.getLocation()

    let source = dependency.airship.getSourceForPackage(installationTarget, dependency.airship.package.defaultSource)

    if (!source) {
      return Array<String>()
    }

    return source.excludedSources.map({ "#{baseLocation}/#{_.location}" })
  }

  public class DependenciesResponse {
    construct(
      visible Array<Dependency> dependencies = Array(),
      visible Array<Dependency> dependenciesDownloaded = Array()
    ) {}
  }

  public async getDependenciesForSource(
    String package,
    String installationTarget,
    PackageSource source,
    Bool: download = true,
    Bool: recursive = true
  ) -> DependenciesResponse {
    return getDependenciesForSource(
      package,
      installationTarget,
      source,
      download,
      recursive,
      DependenciesResponse(),
      HashSet()
    )
  }

  async getDependenciesForSource(
    String package,
    String installationTarget,
    PackageSource source,
    Bool download = true,
    Bool recursive = true,
    DependenciesResponse response,
    HashSet<String> dependenciesAdded
  ) -> DependenciesResponse {
    if (dependenciesAdded.contains(package)) {
      return response
    }

    dependenciesAdded.add(package)

    if (!source?.dependencies) {
      return response
    }

    for (dependency in source.dependencies) {
      if (response.dependencies.none({ _.getLocation() == dependency.getLocation() })) {
        response.dependencies.add(dependency)
      }
      if (dependency.class.isOfType(NpmDependency.class)) {
        continue
      }

      let dependencyPackageFile = File(dependency.getLocation())

      if (!dependencyPackageFile.exists) {
        if (download) {
          downloadDependency(dependency)
          response.dependenciesDownloaded.add(dependency)
        }

        if (!dependencyPackageFile.exists) {
          continue
        }
      }

      let args = [
        "-f", dependencyPackageFile.normalizedLocation
      ]

      airship.propagateArgs(args)

      let childship = Airship(args, airship)

      let packageSource = childship.getSourceForPackage(installationTarget, childship.package.defaultSource)
      log.trace("Found source for #{childship.packageLocation.normalizedLocation} with installation target \"#{installationTarget}\": #packageSource")

      if (packageSource && recursive) {
        getDependenciesForSource(
          dependencyPackageFile.name,
          installationTarget,
          packageSource,
          download,
          recursive,
          response,
          dependenciesAdded
        )
      }
    }

    return response
  }

  public isDependencyInstalled(Dependency dependency) =>
    File(dependency.getLocation()).getChild(".git").isDirectory

  public async downloadDependency(Dependency dependency) {
    if (dependency.class.isOfType(GitHubDependency.class)) {
      downloadGitHubDependency((GitHubDependency)dependency)
    } else {
      throw Exception("Cannot download dependency #dependency")
    }
  }

  public async downloadGitHubDependency(GitHubDependency dependency) {
    let url = dependency.getGitUrl()
    let branch = dependency.branch
    let flatPackageDir = File(dependency.getLocation()):mkdirs()

    if (flatPackageDir.getChild(".git").isDirectory) {
      return
    }

    log.info("Cloning dependency #url (#branch) into '#{flatPackageDir.normalizedLocation}'...")

    let response = Git.clone(
      url,
      depth: 1,
      branch,
      outputDirectory: flatPackageDir.normalizedLocation,
      silent: true
    )

    if (response.exitCode != 0) {
      throw ExecutionFailureException("|
        Failed to install git repo:
        #{response.stderr.join("\n")}
        |")
    }
  }
}